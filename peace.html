<!-- A Time for Peace - v1.0 - 2025-12-13 12:45 AM - PERFECT SYNC -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport">
    <title>A Time for Peace</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,1,0" rel="stylesheet">
    <style>
        body {
            touch-action: none;
            overscroll-behavior: none;
            -webkit-tap-highlight-color: transparent;
            background-color: #000;
        }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px; width: 16px;
            border-radius: 50%; background: #8ec5fc;
            cursor: pointer; margin-top: -6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer;
            background: #e2e8f0; border-radius: 2px;
        }
        
        .modal { transition: opacity 0.3s ease, visibility 0.3s ease; }
        .modal.invisible { opacity: 0; visibility: hidden; pointer-events: none; }
        .modal.visible { opacity: 1; visibility: visible; pointer-events: auto; }
        
        .modal-content { transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
        .scale-in { transform: scale(1); }
        .scale-out { transform: scale(0.95); }

        pre { white-space: pre-wrap; word-wrap: break-word; }
        
        #custom-message-container { pointer-events: auto; }
        #custom-message-container a { color: #8ec5fc; text-decoration: underline; }
    </style>
</head>
<body class="overflow-hidden h-screen w-screen font-sans text-slate-800">

    <canvas class="block absolute top-0 left-0 w-full h-full z-0" id="gameCanvas"></canvas>

    <div class="absolute inset-0 flex flex-col items-center justify-center pointer-events-none z-10 transition-opacity duration-1000 opacity-100 text-white/90 text-center drop-shadow-md" id="overlay">
        <h1 class="text-3xl md:text-5xl font-light mb-4 tracking-widest" id="main-title">A Time for Peace</h1>
        <div id="main-subtitle-container">
            <p class="text-lg md:text-xl font-light leading-relaxed">
                Tap to Bloom<br>
                Double Tap for Hearts<br>
                <span class="text-sm opacity-70 mt-2 block">Drag to Strum</span>
            </p>
        </div>
        <div id="custom-message-container" class="mt-4 hidden bg-black/30 p-4 rounded-lg backdrop-blur-sm max-w-lg text-sm text-left"></div>
    </div>

    <div class="fixed top-5 left-5 flex items-center gap-2 bg-black/40 backdrop-blur px-3 py-2 rounded-full text-white text-xs font-bold tracking-wide opacity-0 transition-opacity z-50 pointer-events-none" id="rec-indicator">
        <div class="w-2.5 h-2.5 bg-red-500 rounded-full animate-pulse"></div>
        REC
    </div>

    <div class="fixed top-5 left-24 flex items-center gap-2 bg-black/40 backdrop-blur px-3 py-2 rounded-full text-white text-xs font-bold tracking-wide opacity-0 transition-opacity z-50 pointer-events-none" id="sync-indicator">
        <div class="w-2.5 h-2.5 bg-amber-400 rounded-full animate-pulse"></div>
        SYNCING
    </div>

    <div class="fixed bottom-3 right-4 text-[10px] text-white/60 pointer-events-none z-10 tracking-wider" id="master-footer">
      â€¢ A Time for Peace â€¢ Penang 2025 â€¢ <span id="clock">--:--</span>
    </div>

    <button class="fixed top-5 right-5 w-12 h-12 bg-white/20 backdrop-blur-md rounded-full flex items-center justify-center text-white hover:bg-white/30 active:scale-95 transition-all shadow-lg z-50" id="settings-trigger">
        <span class="material-symbols-outlined">settings</span>
    </button>

    <aside class="fixed top-0 right-0 w-80 h-full bg-white/95 backdrop-blur-xl shadow-2xl transform transition-transform duration-300 translate-x-full z-50 flex flex-col no-scrollbar overflow-y-auto" id="settings-panel">
        
        <div class="p-6 flex justify-between items-center border-b border-gray-100">
            <h2 class="text-lg font-bold text-gray-700 tracking-wide uppercase">Settings</h2>
            <button class="text-gray-400 hover:text-gray-700 transition-colors" id="close-btn">
                <span class="material-symbols-outlined text-3xl">close</span>
            </button>
        </div>

        <div class="p-6 space-y-8 flex-1">

            <div class="space-y-2">
                <span class="text-xs font-bold text-gray-500 uppercase tracking-wider block">Session Status</span>
                <ul id="session-status-list" class="space-y-2 text-xs text-gray-600">
                    <li class="text-[11px] text-gray-400">No peers yet.</li>
                </ul>
            </div>
            
            <div class="flex justify-between items-center">
                <span class="text-xs font-bold text-gray-500 uppercase tracking-wider">Sound</span>
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="audio-toggle" class="sr-only peer" checked>
                    <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-300"></div>
                </label>
            </div>

            <div class="space-y-2">
                <span class="text-xs font-bold text-gray-500 uppercase tracking-wider block">Musical Scale</span>
                <select id="scale-selector" class="w-full px-4 py-2.5 text-sm text-gray-700 bg-gray-50 border border-gray-200 rounded-lg focus:ring-2 focus:ring-blue-300 focus:border-blue-300 cursor-pointer">
                    <option value="extended_pentatonic">Extended Pentatonic (18 notes)</option>
                    <option value="original">Original Scale (13 notes)</option>
                    <option value="major_pentatonic">Major Pentatonic</option>
                    <option value="minor_pentatonic">Minor Pentatonic</option>
                    <option value="chromatic">Chromatic</option>
                    <option value="whole_tone">Whole Tone</option>
                    <option value="blues">Blues Scale</option>
                </select>
            </div>

            <div class="space-y-3">
                <span class="text-xs font-bold text-gray-500 uppercase tracking-wider block">Background</span>
                <div class="space-y-2">
                    <input class="block w-full text-xs text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-xs file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100" id="bg-upload-input" type="file" accept="image/*">
                    <div class="grid grid-cols-2 gap-2">
                        <button class="w-full py-2 bg-blue-100 text-blue-700 text-xs font-semibold rounded hover:bg-blue-200 transition" id="apply-bg-btn">
                            Apply Image
                        </button>
                        <button class="w-full py-2 bg-gray-100 text-gray-500 text-xs font-medium rounded hover:bg-gray-200 transition" id="reset-bg-btn">
                            Reset Gradient
                        </button>
                    </div>
                </div>
            </div>

            <div class="space-y-2">
                <span class="text-xs font-bold text-gray-500 uppercase tracking-wider block">Custom Words</span>
                <textarea class="w-full p-3 text-sm text-gray-700 bg-gray-50 border border-gray-200 rounded-lg focus:ring-blue-300 focus:border-blue-300 resize-none h-24" id="custom-words" placeholder="e.g. Joy, Peace, Kindness..."></textarea>
            </div>

            <div class="space-y-2">
                <span class="text-xs font-bold text-gray-500 uppercase tracking-wider block">Sprite Pack</span>
                <select id="sprite-mode" class="w-full px-4 py-2.5 text-sm text-gray-700 bg-gray-50 border border-gray-200 rounded-lg focus:ring-2 focus:ring-blue-300 focus:border-blue-300 cursor-pointer">
                    <option value="flowers">Flowers</option>
                    <option value="fireworks">Fireworks</option>
                    <option value="shapes">Shapes</option>
                </select>
            </div>

            <div class="space-y-6">
                <div class="space-y-2">
                    <div class="flex justify-between">
                        <span class="text-xs font-bold text-gray-500 uppercase tracking-wider">Fade Duration (Flowers)</span>
                    </div>
                    <input type="range" id="decay-slider" min="0" max="5" step="1" value="2" class="w-full bg-gray-200 rounded-lg appearance-none cursor-pointer">
                </div>

                <div class="space-y-2">
                    <div class="flex justify-between">
                        <span class="text-xs font-bold text-gray-500 uppercase tracking-wider">Trail Duration & Speed</span>
                    </div>
                    <input type="range" id="trail-slider" min="1" max="10" step="1" value="5" class="w-full bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    <div class="flex justify-between text-[10px] text-gray-400 mt-1">
                        <span>Short/Fast</span>
                        <span>Long/Slow</span>
                    </div>
                </div>

                <div class="space-y-2">
                    <div class="flex justify-between">
                        <span class="text-xs font-bold text-gray-500 uppercase tracking-wider">Growth Speed</span>
                    </div>
                    <input type="range" id="speed-slider" min="1" max="100" value="50" class="w-full bg-gray-200 rounded-lg appearance-none cursor-pointer">
                </div>
            </div>

            <div class="grid grid-cols-2 gap-3 pt-4 border-t border-gray-100">
                <button class="col-span-1 px-4 py-3 bg-orange-50 text-orange-700 text-sm font-semibold rounded-xl hover:bg-orange-100 transition text-center" id="record-btn">Record</button>
                <button class="col-span-1 px-4 py-3 bg-green-50 text-green-700 text-sm font-semibold rounded-xl hover:bg-green-100 transition text-center" id="save-btn">Snapshot</button>
                <button class="col-span-1 px-4 py-3 bg-gray-50 text-gray-700 text-sm font-medium rounded-xl hover:bg-gray-100 transition text-center" id="theme-btn">Theme</button>
                <button class="col-span-1 px-4 py-3 bg-red-50 text-red-700 text-sm font-medium rounded-xl hover:bg-red-100 transition text-center" id="clear-btn">Clear</button>
                
                <button class="col-span-2 mt-2 py-4 bg-amber-50 text-amber-700 font-bold rounded-xl hover:bg-amber-100 transition text-center flex items-center justify-center gap-2 border border-amber-200 shadow-sm" id="secrets-btn">
                    <span class="material-symbols-outlined">key</span> Open Secrets
                </button>

            </div>
        </div>
    </aside>

    <div id="secrets-modal" class="fixed inset-0 bg-black/60 backdrop-blur-sm z-[100] flex items-center justify-center invisible modal">
        <div id="secrets-content" class="bg-white rounded-2xl shadow-2xl w-11/12 max-w-md p-6 transform scale-out modal-content">
            <div class="flex justify-between items-center mb-4 border-b pb-2">
                <h3 class="text-xl font-bold text-gray-800 flex items-center gap-2">
                    <span class="material-symbols-outlined text-amber-500">auto_awesome</span> 
                    Discoveries
                </h3>
                <button id="close-secrets" class="text-gray-400 hover:text-gray-800 p-2 hover:bg-gray-100 rounded-full transition-colors">
                    <span class="material-symbols-outlined">close</span>
                </button>
            </div>

            <div id="secrets-grid-view">
                <p class="text-sm text-gray-500 mb-4">
                    Unlock patterns by experimenting with rhythms (Taps) and flow (Drags). Click a discovery to see its activation code.
                </p>
                <div id="secrets-list" class="grid grid-cols-5 gap-2 max-h-60 overflow-y-auto p-1">
                    </div>
                <div class="text-center text-xs text-gray-400 mt-4">
                    Found: <span id="secrets-count">0</span> / 20
                </div>
            </div>

            <div id="secrets-detail-view" class="hidden flex flex-col">
                <button id="back-to-grid" class="text-xs text-blue-500 mb-2 flex items-center hover:underline self-start">
                    <span class="material-symbols-outlined text-sm mr-1">arrow_back</span> Back
                </button>
                
                <div class="bg-amber-50 rounded-xl p-5 border border-amber-100 text-center space-y-4">
                    <div id="detail-id" class="w-16 h-16 bg-amber-200 rounded-full flex items-center justify-center mx-auto text-amber-800 font-bold text-2xl shadow-inner">?</div>
                    
                    <div>
                        <h4 id="detail-title" class="text-lg font-bold text-amber-900">Secret Unlocked</h4>
                        <p id="detail-type" class="text-xs text-amber-700/70 uppercase tracking-wide font-bold mt-1">RHYTHM</p>
                    </div>

                    <div class="text-left bg-white/60 p-4 rounded-lg text-sm border border-amber-100 shadow-sm">
                        <p class="mb-2"><span class="font-bold text-gray-600 block text-xs uppercase mb-1">Trigger:</span>
                        <span id="detail-trigger" class="font-mono text-lg text-amber-600 tracking-wider bg-amber-50 px-2 py-1 rounded">Tap Tap</span></p>
                        
                        <p><span class="font-bold text-gray-600 block text-xs uppercase mb-1">Visual Effect:</span>
                        <span id="detail-reward" class="italic text-gray-700">Blooming Mandala</span></p>
                    </div>

                    <button id="simulate-btn" class="w-full py-3 bg-gradient-to-r from-amber-400 to-amber-500 text-white rounded-xl font-bold shadow-lg hover:from-amber-500 hover:to-amber-600 active:scale-95 transition flex items-center justify-center gap-2">
                        <span class="material-symbols-outlined">play_circle</span> Play Example
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div id="peer-modal" class="fixed inset-0 bg-black/60 backdrop-blur-sm z-[100] flex items-center justify-center invisible modal">
        <div id="peer-content" class="bg-white rounded-2xl shadow-2xl w-11/12 max-w-lg p-6 transform scale-out modal-content">
            <div class="flex justify-between items-center mb-4 border-b pb-2">
                <div>
                    <h3 id="peer-modal-name" class="text-xl font-bold text-gray-800">Peer</h3>
                    <p id="peer-modal-meta" class="text-xs text-gray-500 mt-1">Connected: --</p>
                </div>
                <button id="close-peer-modal" class="text-gray-400 hover:text-gray-800 p-2 hover:bg-gray-100 rounded-full transition-colors">
                    <span class="material-symbols-outlined">close</span>
                </button>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div class="space-y-3">
                    <div class="text-xs font-bold text-gray-500 uppercase tracking-wider">Connection Details</div>
                    <div class="bg-gray-50 border border-gray-200 rounded-lg p-3 text-xs text-gray-600 space-y-2">
                        <div><span class="font-semibold text-gray-700">Connected at:</span> <span id="peer-connected-at">--</span></div>
                        <div><span class="font-semibold text-gray-700">Duration:</span> <span id="peer-connected-duration">--</span></div>
                    </div>

                    <div class="text-xs font-bold text-gray-500 uppercase tracking-wider">Last 5 Connections</div>
                    <ul id="peer-connection-history" class="space-y-2 text-xs text-gray-600 max-h-44 overflow-y-auto"></ul>
                </div>

            <div class="space-y-3">
                <div class="text-xs font-bold text-gray-500 uppercase tracking-wider">Chat</div>
                <div id="peer-chat-history" class="bg-gray-50 border border-gray-200 rounded-lg p-3 text-xs text-gray-700 h-48 overflow-y-auto space-y-2"></div>
                <div class="flex items-center justify-between text-[11px] text-gray-400">
                    <span>Translation</span>
                    <select id="peer-chat-translation" class="border border-gray-200 rounded px-2 py-1 text-[11px] text-gray-600">
                        <option value="none">Off</option>
                        <option value="en">English</option>
                        <option value="th">Thai</option>
                        <option value="es">Spanish</option>
                        <option value="fr">French</option>
                    </select>
                </div>
                <div class="flex gap-2">
                    <input id="peer-chat-input" type="text" class="flex-1 px-3 py-2 text-xs border border-gray-200 rounded-lg focus:ring-2 focus:ring-blue-300 focus:border-blue-300" placeholder="Type a message...">
                    <button id="peer-chat-send" class="px-3 py-2 bg-blue-500 text-white text-xs font-semibold rounded-lg hover:bg-blue-600 transition">Send</button>
                </div>
            </div>
            </div>
        </div>
    </div>

    <script>
        const config = {
            currentThemeIndex: 0,
            defaultWords: [
                "Peace", "Gentle", "Warmth", "Love", "Hope", "Empathy", "Calm", "Grace", "Kindness", "Light", "Joy", "Bliss",
                "Serenity", "Breathe Deep", "Be Here", "Soften", "Let Go", "ðŸª·ðŸª·ðŸª·", "Balance", "Harmony",
                "Inner Peace", "Radiate", "Stillness", "Presence", "Gratitude", "Acceptance", "Flow", "Healing", "Strength",
                "Wisdom", "Patience", "Courage", "â˜•â˜•â˜•", " ðŸ˜´ðŸ˜´ðŸ˜´", "à¸”à¸µà¸—à¸µà¹ˆà¸ªà¸¸à¸”à¸­à¸¢à¹ˆà¸²à¸‡à¹à¸—à¹‰à¸ˆà¸£à¸´à¸‡", "Relax...", "Deep Breath", "à¸«à¸²à¸¢à¹ƒà¸ˆà¹€à¸‚à¹‰à¸²à¸¥à¸¶à¸à¹†"
            ],
            customWords: [],
            speedMultiplier: 1.0,
            decayValue: 0.005,
            trailDecay: 0.01,
            trailSpeed: 1.0,
            useGradient: true,
            backgroundImage: null,
            backgroundImageData: null,
            currentTrail: 'â™¥',
            lastTrailSwitch: Date.now(),
            currentScale: 'original',
            spriteMode: 'flowers'
        };

        const SPRITE_MODE_STORAGE_KEY = 'peace_sprite_mode';

        const themes = [
            { bg: ['#e0c3fc', '#8ec5fc'], text: '#4a148c' },
            { bg: ['#fad0c4', '#ffd1ff'], text: '#880e4f' },
            { bg: ['#d299c2', '#fef9d7'], text: '#3e2723' },
            { bg: ['#a1c4fd', '#c2e9fb'], text: '#01579b' },
            { bg: ['#d4fc79', '#96e6a1'], text: '#1b5e20' }
        ];

        const BG_DB_NAME = 'peace_assets';
        const BG_STORE_NAME = 'backgrounds';
        const BG_STORE_KEY = 'peace_bg';
        let bgDbPromise = null;

        function openBackgroundDb() {
            if (!('indexedDB' in window)) return Promise.resolve(null);
            if (bgDbPromise) return bgDbPromise;
            bgDbPromise = new Promise(resolve => {
                const request = indexedDB.open(BG_DB_NAME, 1);
                request.onupgradeneeded = () => {
                    const db = request.result;
                    if (!db.objectStoreNames.contains(BG_STORE_NAME)) {
                        db.createObjectStore(BG_STORE_NAME);
                    }
                };
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => {
                    console.warn('IndexedDB unavailable for background image.');
                    resolve(null);
                };
            });
            return bgDbPromise;
        }

        async function saveBackgroundImage(dataUrl) {
            const db = await openBackgroundDb();
            if (!db) return false;
            return new Promise(resolve => {
                const tx = db.transaction(BG_STORE_NAME, 'readwrite');
                tx.oncomplete = () => resolve(true);
                tx.onerror = () => {
                    console.warn('Failed to persist background image.');
                    resolve(false);
                };
                tx.objectStore(BG_STORE_NAME).put(dataUrl, BG_STORE_KEY);
            });
        }

        async function loadBackgroundImage() {
            const db = await openBackgroundDb();
            if (!db) return null;
            return new Promise(resolve => {
                const tx = db.transaction(BG_STORE_NAME, 'readonly');
                const request = tx.objectStore(BG_STORE_NAME).get(BG_STORE_KEY);
                request.onsuccess = () => resolve(request.result || null);
                request.onerror = () => resolve(null);
            });
        }

        async function clearBackgroundImage() {
            const db = await openBackgroundDb();
            if (!db) return false;
            return new Promise(resolve => {
                const tx = db.transaction(BG_STORE_NAME, 'readwrite');
                tx.oncomplete = () => resolve(true);
                tx.onerror = () => resolve(false);
                tx.objectStore(BG_STORE_NAME).delete(BG_STORE_KEY);
            });
        }

        function compressBackgroundDataUrl(dataUrl, { maxDimension = 1600, quality = 0.85 } = {}) {
            return new Promise(resolve => {
                const img = new Image();
                img.onload = () => {
                    const maxSide = Math.max(img.width, img.height);
                    const scale = maxSide > maxDimension ? (maxDimension / maxSide) : 1;
                    const targetWidth = Math.max(1, Math.round(img.width * scale));
                    const targetHeight = Math.max(1, Math.round(img.height * scale));
                    const canvas = document.createElement('canvas');
                    canvas.width = targetWidth;
                    canvas.height = targetHeight;
                    const ctx = canvas.getContext('2d');
                    if (!ctx) {
                        resolve(dataUrl);
                        return;
                    }
                    ctx.drawImage(img, 0, 0, targetWidth, targetHeight);
                    const compressed = canvas.toDataURL('image/jpeg', quality);
                    resolve(compressed || dataUrl);
                };
                img.onerror = () => resolve(dataUrl);
                img.src = dataUrl;
            });
        }

        const secretWords = [
            "Hi Joy  :)",
            "Clarity",
            "Unity",
            "Wholeness",
            "à¸ˆà¸­à¸¢à¸›à¸£à¸°à¸ªà¸šà¸„à¸§à¸²à¸¡à¸ªà¸³à¹€à¸£à¹‡à¸ˆ",
            "à¸„à¸§à¸²à¸¡à¸ªà¸¸à¸‚à¸¢à¹ˆà¸­à¸¡à¸„à¸¹à¹ˆà¸„à¸§à¸£à¸à¸±à¸šà¸„à¸§à¸²à¸¡à¸ªà¸‡à¸šà¸ªà¸¸à¸‚à¹à¸¥à¸°à¸„à¸§à¸²à¸¡à¹€à¸ˆà¸£à¸´à¸à¸£à¸¸à¹ˆà¸‡à¹€à¸£à¸·à¸­à¸‡",
            "â¤ï¸â¤ï¸â¤ï¸",
            "Joy ðŸª·à¹€à¸à¸µà¹ˆà¸¢à¸§à¸”à¸­à¸‡à¸à¸±à¸™",
            "Joy ðŸµï¸",
            "à¸­à¸²à¸—à¸£ ðŸŒ¼",
            "à¸­à¸²à¸—à¸£",
            "à¸ˆà¸´à¸•à¸§à¸´à¸à¸à¸²à¸“à¸—à¸µà¹ˆà¸‡à¸”à¸‡à¸²à¸¡"
        ];

        const scales = {
            extended_pentatonic: [130.81, 146.83, 164.81, 196.00, 220.00, 261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 587.33, 659.25, 783.99, 880.00, 1046.50, 1174.66, 1318.51],
            original: [329.63, 369.99, 392.00, 440.00, 493.88, 523.25, 587.33, 659.25, 739.99, 880.00, 987.77, 1174.66, 1318.51],
            major_pentatonic: [261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 587.33, 659.25, 783.99, 880.00, 1046.50, 1174.66, 1318.51],
            minor_pentatonic: [220.00, 261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 587.33, 659.25, 783.99, 880.00, 1046.50],
            chromatic: [261.63, 277.18, 293.66, 311.13, 329.63, 349.23, 369.99, 392.00, 415.30, 440.00, 466.16, 493.88],
            whole_tone: [261.63, 293.66, 329.63, 369.99, 415.30, 466.16, 523.25, 587.33, 659.25, 739.99, 830.61, 932.33],
            blues: [261.63, 311.13, 349.23, 369.99, 392.00, 466.16, 523.25, 622.25, 698.46, 739.99, 783.99, 932.33]
        };
        
        let visualEntities = [];
        let wordEntities = [];
        let particles = []; 
        let presencePulses = [];
        let foundEggs = JSON.parse(localStorage.getItem('peace_egg_ids') || "[]");
        let inputBuffer = "";
        let pendingAudioEvents = [];

        const ZenAudio = {
            ctx: null, 
            enabled: true, 
            masterGain: null, 
            dest: null, 
            bgBuffer: null,
            bgSource: null,
            bgGain: null,
            pluckBuffers: {},
            scale: scales.original,
            hasUserInteracted: false,
            
            init: function() {
                if (!this.ctx && (window.AudioContext || window.webkitAudioContext)) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.gain.value = 0.3;
                    
                    this.dest = this.ctx.createMediaStreamDestination();
                    this.masterGain.connect(this.ctx.destination);
                    this.masterGain.connect(this.dest);
                    
                    this.generatePluckBuffers();
                }
            },

            generatePluckBuffers: function() {
                if (!this.ctx) return;
                this.pluckBuffers = {};

                this.scale.forEach(freq => {
                    const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 2.0, this.ctx.sampleRate);
                    const data = buffer.getChannelData(0);
                    const delayLength = Math.floor(this.ctx.sampleRate / freq);
                    let idx = 0, last = 0;
                    
                    const noise = new Float32Array(delayLength).map(() => Math.random()*2-1);
                    
                    for (let i = 0; i < buffer.length; i++) {
                        const sample = (noise[idx] + last) * 0.5 * 0.99; 
                        last = noise[idx]; 
                        noise[idx] = sample;
                        data[i] = sample;
                        idx = (idx + 1) % delayLength;
                    }
                    
                this.pluckBuffers[freq] = buffer;
            });
            },

            changeScale: function(scaleName) {
                if (scales[scaleName]) {
                    this.scale = scales[scaleName];
                    this.generatePluckBuffers();
                }
            },

            loadBackground: async function(url) {
                if (!this.ctx) this.init();
                try {
                    const response = await fetch(url);
                    const arrayBuffer = await response.arrayBuffer();
                    this.bgBuffer = await this.ctx.decodeAudioData(arrayBuffer);
                } catch(e) {
                    console.error("Failed to load background audio:", e);
                }
            },

            playBackground: function() {
                if (!this.bgBuffer || !this.ctx) return;
                
                if (this.bgSource) {
                    try { this.bgSource.stop(); } catch(e) {}
                }
                
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
                
                this.bgSource = this.ctx.createBufferSource();
                this.bgSource.buffer = this.bgBuffer;
                this.bgSource.loop = true;
                
                if (!this.bgGain) {
                    this.bgGain = this.ctx.createGain();
                    this.bgGain.connect(this.masterGain);
                }
                this.bgGain.gain.value = 0.2;
                
                this.bgSource.connect(this.bgGain);
                this.bgSource.start(0);
            },

            softenEntry: function() {
                if (!this.ctx || !this.masterGain || !this.enabled) return;
                const now = this.ctx.currentTime;
                const startGain = Math.min(this.masterGain.gain.value || 0.3, 0.12);
                this.masterGain.gain.cancelScheduledValues(now);
                this.masterGain.gain.setValueAtTime(startGain, now);
                this.masterGain.gain.linearRampToValueAtTime(0.3, now + 1.2);
            },

            warmUp: function() {
                if (!this.ctx) this.init();
                if (this.ctx && (this.ctx.state === 'suspended' || this.ctx.state === 'interrupted')) {
                    this.ctx.resume();
                }
                
                if (this.ctx && this.enabled) {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    gain.gain.value = 0.001; 
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.01);
                }
            },

            getFreqIndex: function(y, height) {
                const norm = 1 - Math.max(0, Math.min(1, y / height));
                return Math.floor(norm * (this.scale.length - 1));
            },
            
            playPluckScheduled: function(freq, volume = 0.3, when = 0) {
                if (!this.ctx || !this.enabled) return;
                if (this.ctx.state !== 'running') this.ctx.resume().catch(()=>{});

                const buffer = this.pluckBuffers[freq];
                if (!buffer) return;

                if (!this.hasUserInteracted) {
                    this.hasUserInteracted = true;
                    this.masterGain.gain.cancelScheduledValues(this.ctx.currentTime);
                    this.masterGain.gain.setValueAtTime(0.05, this.ctx.currentTime);
                    this.masterGain.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 0.2);
                }

                const src = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                gain.gain.value = volume;
                
                src.buffer = buffer;
                src.connect(gain);
                gain.connect(this.masterGain);
                
                const startTime = when > 0 ? when : this.ctx.currentTime;
                src.start(startTime);
            },
            
            playChord: function(baseIdx, when = 0) {
                if (!this.ctx || !this.enabled) return;
                const startTime = when > 0 ? when : this.ctx.currentTime;
                
                this.playPluckScheduled(this.scale[baseIdx], 0.2, startTime);
                
                const idx2 = Math.min(this.scale.length-1, baseIdx + 2);
                this.playPluckScheduled(this.scale[idx2], 0.15, startTime + 0.04);
                
                const idx3 = Math.min(this.scale.length-1, baseIdx + 4);
                this.playPluckScheduled(this.scale[idx3], 0.15, startTime + 0.08);
            },
            
            playDiscovery: function() {
                if (!this.ctx || !this.enabled) return;
                const startTime = this.ctx.currentTime;
                [261.63, 329.63, 392.00, 523.25].forEach((f, i) => { 
                    this.playPluckScheduled(f, 0.2, startTime + (i * 0.15)); 
                });
            }
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        function resize() {
            const dpr = window.devicePixelRatio || 1;
            width = window.innerWidth;
            height = window.innerHeight;
            
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            
            ctx.scale(dpr, dpr);
            
            document.getElementById('settings-panel').style.height = `${window.innerHeight}px`;
        }
        window.addEventListener('resize', resize);
        window.addEventListener('orientationchange', () => { setTimeout(resize, 100); });
        resize();

        const random = (min, max, rng = Math.random) => rng() * (max - min) + min;
        function createSeededRng(seed) {
            let t = seed >>> 0;
            return function() {
                t += 0x6D2B79F5;
                let r = Math.imul(t ^ (t >>> 15), 1 | t);
                r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
                return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
            };
        }
        function getPastelColor(rng = Math.random) { 
            const hue = random(0, 360, rng);
            return { hue: hue, str: `hsla(${hue}, 70%, 80%,` };
        }
        function getRandomWord(rng = Math.random) {
            if (config.customWords.length > 0) return config.customWords[Math.floor(rng() * config.customWords.length)];
            return config.defaultWords[Math.floor(rng() * config.defaultWords.length)];
        }

        class Particle {
            constructor(x, y, color, options = {}) {
                this.x = x; this.y = y;
                this.vx = options.vx ?? random(-3, 3);
                this.vy = options.vy ?? random(-5, 1);
                this.life = 1.0; this.decay = random(0.005, 0.02);
                this.color = color;
                this.gravity = 0.1;
                this.sparkleColor = `hsl(${random(0,360)}, 80%, 70%)`;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.vy += this.gravity;
                this.life -= this.decay;
            }
            draw(ctx) {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.sparkleColor;
                ctx.fillRect(this.x, this.y, 2, 2);
            }
            isDead() { return this.life <= 0; }
        }

        class PresencePulse {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.life = 1;
                this.radius = 10;
            }
            update() {
                this.radius += 1.6;
                this.life -= 0.02;
            }
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = Math.max(0, this.life * 0.35);
                ctx.strokeStyle = "rgba(255,255,255,0.5)";
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
            isDead() { return this.life <= 0; }
        }

        class Word {
            constructor(x, y, text, options = {}) {
                this.x = x; this.y = y; this.text = text || getRandomWord();
                this.velocity = -0.5; this.alpha = 0; this.fadeIn = true;
                this.color = options.color || themes[config.currentThemeIndex].text; 
            }
            update() {
                this.y += this.velocity * config.speedMultiplier;
                if (this.fadeIn) { this.alpha += 0.02 * config.speedMultiplier; if (this.alpha>=1) this.fadeIn=false; } 
                else if (config.decayValue > 0) { this.alpha -= config.decayValue * config.speedMultiplier; }
            }
            draw(ctx) {
                ctx.save(); ctx.globalAlpha = Math.max(0, this.alpha);
                ctx.font = "20px 'Segoe UI', sans-serif"; ctx.fillStyle = this.color;
                ctx.textAlign = "center"; ctx.shadowBlur = 4; ctx.shadowColor = "rgba(0,0,0,0.5)";
                ctx.fillText(this.text, this.x, this.y); ctx.restore();
            }
            isDead() { return this.alpha <= 0 && !this.fadeIn; }
        }

        function addPresencePulse() {
            const edge = Math.floor(Math.random() * 4);
            let x = width / 2;
            let y = height / 2;
            if (edge === 0) { x = random(40, width - 40); y = 20; }
            if (edge === 1) { x = width - 20; y = random(40, height - 40); }
            if (edge === 2) { x = random(40, width - 40); y = height - 20; }
            if (edge === 3) { x = 20; y = random(40, height - 40); }
            presencePulses.push(new PresencePulse(x, y));
        }

        class Bloom {
            constructor(x, y, size=null, options = {}) {
                const rng = options.rng || Math.random;
                this.x = x; this.y = y; this.size = 0; 
                this.maxSize = options.maxSize ?? size ?? random(30, 80, rng);
                const hue = options.hue ?? random(0, 360, rng);
                this.colorObj = { hue: hue, str: `hsla(${hue}, 70%, 80%,` };
                this.colorBase = this.colorObj.str;
                this.petals = options.petals ?? Math.floor(random(5, 9, rng));
                this.alpha = 1; 
                this.compColor = `hsla(${(this.colorObj.hue + 180)%360}, 60%, 70%,`;
                this.rotation = options.rotation ?? random(0, Math.PI*2, rng);
                if (options.shape) {
                    this.shape = options.shape;
                } else {
                    const shapeRoll = rng();
                    this.shape = shapeRoll > 0.6 ? 'pointed' : (shapeRoll > 0.3 ? 'round' : 'hybrid');
                }
            }
            update() {
                this.rotation += 0.002;
                if (this.size < this.maxSize) this.size += 0.5 * config.speedMultiplier;
                else if (config.decayValue > 0) this.alpha -= config.decayValue * config.speedMultiplier;
            }
            draw(ctx) {
                ctx.save();
                
                if(foundEggs.includes(2)) {
                    ctx.strokeStyle = `rgba(218, 165, 32, ${this.alpha * 0.6})`;
                    ctx.lineWidth = 0.5;
                    for(let i=0; i<5; i++) {
                        const angle = (i/5) * Math.PI*2 + this.rotation;
                        const len = this.size * 1.5;
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.bezierCurveTo(this.x + Math.cos(angle - 0.4) * len * 0.5, this.y + Math.sin(angle - 0.4) * len * 0.5,
                            this.x + Math.cos(angle + 0.4) * len * 0.8, this.y + Math.sin(angle + 0.4) * len * 0.8,
                            this.x + Math.cos(angle) * len, this.y + Math.sin(angle) * len);
                        ctx.stroke(); 
                    }
                }

                for(let i=0; i<3; i++) {
                    ctx.fillStyle = this.colorBase + (this.alpha * 0.7 * (1 - i*0.2)) + ')';
                    ctx.beginPath();
                    for (let j = 0; j < this.petals; j++) {
                        const angle = (j / this.petals) * Math.PI * 2 + (i * 0.1) + this.rotation;
                        const petalSize = (this.size - (i*5));
                        if (petalSize <= 0) continue;
                        
                        ctx.moveTo(this.x, this.y);
                        if(this.shape === 'pointed') {
                            ctx.quadraticCurveTo(
                                this.x + Math.cos(angle - 0.3) * petalSize, 
                                this.y + Math.sin(angle - 0.3) * petalSize,
                                this.x + Math.cos(angle) * petalSize * 1.2,
                                this.y + Math.sin(angle) * petalSize * 1.2
                            );
                            ctx.quadraticCurveTo(
                                this.x + Math.cos(angle + 0.3) * petalSize,
                                this.y + Math.sin(angle + 0.3) * petalSize,
                                this.x, this.y
                            );
                        } else {
                            ctx.ellipse(this.x + Math.cos(angle)*(petalSize*0.5), this.y + Math.sin(angle)*(petalSize*0.5), petalSize*0.4, petalSize*0.2, angle, 0, Math.PI*2);
                        }
                    }
                    ctx.fill();
                }

                const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size * 0.25);
                const centerAlpha = foundEggs.includes(1) ? 0.9 : 0.7; 
                grad.addColorStop(0, `rgba(255, 255, 255, ${centerAlpha})`); 
                grad.addColorStop(0.4, this.compColor + (this.alpha * centerAlpha) + ")"); 
                grad.addColorStop(1, this.compColor + "0)"); 
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size * 0.25, 0, Math.PI*2); ctx.fill();
                
                ctx.strokeStyle = `rgba(255,255,255,${this.alpha*0.6})`;
                ctx.lineWidth = 1;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size*0.1, 0, Math.PI*2); ctx.stroke();
                
                if(this.size > 20) {
                    ctx.fillStyle = `rgba(255,255,200,${this.alpha})`;
                    for(let k=0; k<6; k++) {
                        const dotA = (k/6)*Math.PI*2 + this.rotation;
                        const dotR = this.size * 0.2;
                        ctx.beginPath(); ctx.arc(this.x + Math.cos(dotA)*dotR, this.y + Math.sin(dotA)*dotR, 1.5, 0, Math.PI*2); ctx.fill();
                    }
                }

                ctx.restore();
            }
            isDead() { 
                if (this.alpha <= 0 && foundEggs.includes(5)) {
                    for(let k=0; k<15; k++) particles.push(new Particle(this.x, this.y, this.colorBase + '1)'));
                }
                return this.alpha <= 0; 
            }
        }

        class ShapePulse {
            constructor(x, y, options = {}) {
                const rng = options.rng || Math.random;
                this.x = x;
                this.y = y;
                this.size = 0;
                this.maxSize = options.maxSize ?? random(30, 70, rng);
                this.rotation = random(0, Math.PI * 2, rng);
                this.spin = random(-0.02, 0.02, rng);
                this.color = options.color ?? `hsla(${random(180, 300, rng)}, 70%, 75%,`;
                this.alpha = 1;
            }
            update() {
                this.rotation += this.spin;
                if (this.size < this.maxSize) this.size += 0.6 * config.speedMultiplier;
                else if (config.decayValue > 0) this.alpha -= config.decayValue * config.speedMultiplier;
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.globalAlpha = Math.max(0, this.alpha);
                ctx.strokeStyle = this.color + `${this.alpha})`;
                ctx.lineWidth = 2;
                const size = this.size;
                ctx.beginPath();
                ctx.rect(-size / 2, -size / 2, size, size);
                ctx.stroke();
                ctx.restore();
            }
            isDead() { return this.alpha <= 0; }
        }

        class GrowingHeart {
            constructor(x, y, options = {}) {
                const rng = options.rng || Math.random;
                this.x = x; this.y = y; this.size = 0; 
                this.maxSize = options.maxSize ?? random(40, 90, rng);
                this.hue = options.hue ?? random(0, 360, rng);
                this.alpha = 1;
            }
            update() {
                if (this.size < this.maxSize) this.size += 0.5 * config.speedMultiplier;
                else if (config.decayValue > 0) this.alpha -= config.decayValue * config.speedMultiplier;
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                const scale = this.size / 30;
                ctx.scale(scale, scale);
                ctx.globalAlpha = Math.max(0, this.alpha);

                let grad = ctx.createRadialGradient(-5, -5, 2, 0, 0, 25);
                grad.addColorStop(0, "white"); 
                grad.addColorStop(0.3, `hsl(${this.hue}, 100%, 70%)`); 
                grad.addColorStop(1, `hsl(${this.hue}, 100%, 30%)`); 
                ctx.fillStyle = grad;

                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.bezierCurveTo(-10, -10, -20, 0, 0, 20);
                ctx.bezierCurveTo(20, 0, 10, -10, 0, 0);
                ctx.fill();
                
                ctx.strokeStyle = `rgba(255,255,255,${this.alpha*0.5})`;
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.restore();
            }
            isDead() { return this.alpha <= 0; }
        }

        class HeartBloom extends Bloom {
            draw(ctx) {
                ctx.save();
                const layerCount = foundEggs.includes(3) ? 5 : 3;
                for(let i=0; i<layerCount; i++) {
                    const scale = (this.size - (i*4)) / 20;
                    if (scale <= 0) continue;
                    const pCount = this.petals + (i%2); 
                    for (let j = 0; j < pCount; j++) {
                        ctx.save();
                        const angle = (j / pCount) * Math.PI * 2 + this.rotation + (i*0.2);
                        ctx.translate(this.x, this.y);
                        ctx.rotate(angle + Math.PI/2);
                        ctx.translate(0, -scale * 15);
                        ctx.scale(scale, scale);
                        
                        let grad = ctx.createRadialGradient(-3, -3, 1, 0, 0, 15);
                        grad.addColorStop(0, "rgba(255,255,255,0.4)");
                        grad.addColorStop(1, this.colorBase + (this.alpha * 0.8) + ')');
                        ctx.fillStyle = grad;

                        ctx.beginPath();
                        ctx.moveTo(0,0);
                        ctx.bezierCurveTo(-5, -5, -10, 0, 0, 10);
                        ctx.bezierCurveTo(10, 0, 5, -5, 0, 0);
                        ctx.fill();
                        ctx.restore();
                    }
                }
                ctx.fillStyle = this.compColor + this.alpha + ')';
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size * 0.1, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            }
        }

        class HeartCloud {
            constructor(x, y, options = {}) {
                const rng = options.rng || Math.random;
                this.x = x; this.y = y; this.alpha = 1;
                this.hearts = [];
                if (options.hearts) {
                    this.hearts = options.hearts.map(h => ({ ...h }));
                } else {
                    const count = Math.floor(random(4, 12, rng));
                    const colors = ["#ff0000", "#ff7f00", "#ffff00", "#00ff00", "#0000ff", "#4b0082", "#9400d3", "#ff1493"];
                    for(let i=0; i<count; i++) {
                        this.hearts.push({
                            ox: random(-40, 40, rng), oy: random(-40, 40, rng),
                            size: random(10, 25, rng),
                            color: colors[Math.floor(rng() * colors.length)],
                            rot: random(-0.2, 0.2, rng)
                        });
                    }
                }
            }
            update() {
                this.y -= 0.5 * config.speedMultiplier;
                if (config.decayValue > 0) this.alpha -= config.decayValue * config.speedMultiplier;
            }
            draw(ctx) {
                ctx.save(); ctx.globalAlpha = Math.max(0, this.alpha);
                this.hearts.forEach(h => {
                    ctx.save();
                    ctx.translate(this.x + h.ox, this.y + h.oy);
                    ctx.rotate(h.rot);
                    const scale = h.size / 20;
                    ctx.scale(scale, scale);
                    
                    let grad = ctx.createRadialGradient(-5, -5, 2, 0, 0, 20);
                    grad.addColorStop(0, "white");
                    grad.addColorStop(0.3, h.color);
                    grad.addColorStop(1, "#330000");
                    ctx.fillStyle = grad;
                    
                    ctx.beginPath();
                    ctx.moveTo(0,0);
                    ctx.bezierCurveTo(-10, -10, -20, 0, 0, 20);
                    ctx.bezierCurveTo(20, 0, 10, -10, 0, 0);
                    ctx.fill();
                    ctx.restore();
                });
                ctx.restore();
            }
            isDead() { return this.alpha <= 0; }
        }

        class TrailBase {
            constructor(x, y, type, options = {}) {
                const rng = options.rng || Math.random;
                this.x = x; this.y = y; this.alpha = 1; 
                this.size = options.size ?? random(10, 20, rng);
                this.type = type; 
                this.hue = options.hue ?? random(0, 360, rng);
                this.color = options.color ?? `hsl(${this.hue},100%,60%)`; 
                this.cometColor = options.cometColor ?? `hsl(${random(200,260, rng)},100%,80%)`;
            }
            update() {
                this.y -= config.trailSpeed; 
                this.alpha -= config.trailDecay; 
            }
            draw(ctx) {
                ctx.save(); ctx.globalAlpha = Math.max(0, this.alpha);
                
                if(this.type === "Comet") {
                    ctx.fillStyle = this.cometColor;
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.size/3, 0, Math.PI*2); ctx.fill();
                } 
                else if (this.type === "â™¥" || this.type === "â­") {
                    ctx.translate(this.x, this.y);
                    
                    if(this.type === "â™¥") {
                        ctx.fillStyle = this.color;
                        ctx.font = `${this.size}px serif`;
                        ctx.fillText("â™¥", 0, 0);
                    } else {
                        ctx.fillStyle = this.color;
                        ctx.font = `${this.size}px serif`;
                        ctx.fillText("â­", 0, 0);
                    }
                } 
                else {
                    ctx.fillStyle = "rgba(255,255,255,0.9)";
                    ctx.font = `${this.size}px serif`;
                    ctx.fillText(this.type, this.x, this.y);
                }
                ctx.restore();
            }
            isDead() { return this.alpha <= 0; }
        }

        const RELAY_SESSION_ID = `peace:${window.location.pathname.replace(/\/+$/, '') || '/'}`.replace(/[^a-z0-9:/_-]/gi, '_').toLowerCase();
        if (window.location.search) {
            const cleanUrl = new URL(window.location.href);
            cleanUrl.search = '';
            history.replaceState({}, document.title, cleanUrl.toString());
        }
        const RELAY_SIGNAL_HTTP_URL = 'https://gift-signal.myacctfortracking.workers.dev/signal';
        const RELAY_SIGNAL_WS_URL = 'wss://gift-signal.myacctfortracking.workers.dev/signal';
        const CLIENT_ID_STORAGE_KEY = `peace_client_id_${RELAY_SESSION_ID}`;
        let storedClientId = null;
        try {
            storedClientId = localStorage.getItem(CLIENT_ID_STORAGE_KEY);
        } catch (_) {}
        let resolvedClientId = storedClientId;
        if (!resolvedClientId) {
            resolvedClientId = (crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2, 12));
            try {
                localStorage.setItem(CLIENT_ID_STORAGE_KEY, resolvedClientId);
            } catch (_) {}
        }
        const RELAY_CLIENT_ID = resolvedClientId;
        const RELAY_DRAG_THROTTLE_MS = 20;
        const RELAY_RECONNECT_BASE_MS = 800;
        const RELAY_RECONNECT_MAX_MS = 10000;
        const RELAY_CONNECT_TIMEOUT_MS = 8000;
        const REMOTE_ENTRY_DAMPEN_MS = 5000;
        const SNAPSHOT_DEBOUNCE_MS = 1200;
        const RELAY_LOG_SLOT_COUNT = 15;
        const RELAY_LOG_SLOT_DURATION_MS = 2 * 60 * 1000;
        const RELAY_LOG_SLOT_PREFIX = 'peace_relay_log_slot_';
        const RELAY_LOG_META_KEY = 'peace_relay_log_meta';
        const RELAY_LOGGABLE_TYPES = new Set(['tap', 'drag', 'state', 'snapshot']);
        const relayState = { ws: null, reconnectTimer: null, reconnectAttempts: 0, connectTimeoutTimer: null };
        const relayQueue = [];
        const relayHandshake = {
            active: false,
            snapshotApplied: false,
            reason: null,
            timeoutTimer: null,
            snapshotFound: false,
            snapshotFetched: false
        };
        const storedStateTs = Number(localStorage.getItem('peace_state_ts'));
        const syncState = {
            lastStateTs: 0,
            initialSent: false,
            lastLocalStateTs: Number.isFinite(storedStateTs) && storedStateTs > 0 ? storedStateTs : Date.now()
        };
        let remoteStateApplied = false;
        let localStateDirty = false;
        const syncIndicator = document.getElementById('sync-indicator');
        const sessionStatusList = document.getElementById('session-status-list');

        let lastTap=0, lastTapX=null, lastTapY=null, isDragging=false, dragStart=0, startX=null, startY=null, lastDragSound=0;
        let lastRelayDragSend = 0;
        let lastRemoteDragSound = 0;
        let remoteEntryDampenUntil = 0;
        
        let relayKeepaliveTimer = null;
        let snapshotTimer = null;
        const JOIN_NAME_STORAGE_KEY = 'peace_join_name';
        const RELAY_KEEPALIVE_MS = 20000;
        function ensureJoinName() {
            let storedName = localStorage.getItem(JOIN_NAME_STORAGE_KEY);
            if (!storedName || !storedName.trim()) {
                const prompted = (window.prompt('Welcome! Enter your name for this session:', '') || '').trim();
                storedName = prompted || 'Anonymous';
                localStorage.setItem(JOIN_NAME_STORAGE_KEY, storedName);
                localStorage.setItem('peace_joined_at', new Date().toISOString());
            }
            return storedName;
        }
        const joinState = {
            name: ensureJoinName()
        };
        const DOUBLE_TAP_WINDOW = 240;
        const DOUBLE_TAP_DISTANCE = 40;
        const RELAY_PRESENCE_INTERVAL_MS = 12000;
        const RELAY_PRESENCE_STALE_MS = 30000;
        const SESSION_STATUS_RENDER_MS = 5000;
        const peerPresence = new Map();
        const peerConnectionHistory = new Map();
        const peerChatHistory = new Map();
        let activePeerModalId = null;
        let unreadChatCount = 0;
        let chatTranslationTarget = 'none';
        const chatTranslationCache = new Map();
        let presenceTimer = null;
        let presenceRenderTimer = null;
        let localPresenceState = 'active';

        function getPeerHistoryKey(peerId) {
            return `peace_peer_history_${RELAY_SESSION_ID}_${peerId}`;
        }

        function getPeerChatKey(peerId) {
            return `peace_peer_chat_${RELAY_SESSION_ID}_${peerId}`;
        }

        function loadPeerHistory(peerId) {
            if (peerConnectionHistory.has(peerId)) return peerConnectionHistory.get(peerId);
            let history = [];
            try {
                const raw = localStorage.getItem(getPeerHistoryKey(peerId));
                history = raw ? JSON.parse(raw) : [];
            } catch (_) {
                history = [];
            }
            peerConnectionHistory.set(peerId, history);
            return history;
        }

        function savePeerHistory(peerId, history) {
            peerConnectionHistory.set(peerId, history);
            try {
                localStorage.setItem(getPeerHistoryKey(peerId), JSON.stringify(history.slice(-5)));
            } catch (_) {}
        }

        function loadPeerChat(peerId) {
            if (peerChatHistory.has(peerId)) return peerChatHistory.get(peerId);
            let history = [];
            try {
                const raw = localStorage.getItem(getPeerChatKey(peerId));
                history = raw ? JSON.parse(raw) : [];
            } catch (_) {
                history = [];
            }
            peerChatHistory.set(peerId, history);
            return history;
        }

        function savePeerChat(peerId, history) {
            peerChatHistory.set(peerId, history);
            try {
                localStorage.setItem(getPeerChatKey(peerId), JSON.stringify(history.slice(-200)));
            } catch (_) {}
        }

        function formatTimestamp(ts) {
            if (!ts) return '--';
            return new Date(ts).toLocaleString();
        }

        function formatDuration(ms) {
            if (!Number.isFinite(ms) || ms < 0) return '--';
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes}m ${seconds}s`;
        }

        function updateUnreadChatTitle() {
            const baseTitle = document.title.replace(/^\(\d+\)\s*/, '');
            if (unreadChatCount > 0) {
                document.title = `(${unreadChatCount}) ${baseTitle}`;
            } else {
                document.title = baseTitle;
            }
        }

        function resetUnreadChat() {
            unreadChatCount = 0;
            updateUnreadChatTitle();
        }

        function handleIncomingChatAlert(senderName, messageText) {
            const shouldNotify = document.hidden || !document.hasFocus();
            if (!shouldNotify) return;
            unreadChatCount += 1;
            updateUnreadChatTitle();
            if ('Notification' in window) {
                if (Notification.permission === 'granted') {
                    new Notification(`Message from ${senderName}`, { body: messageText || '' });
                } else if (Notification.permission !== 'denied') {
                    Notification.requestPermission().then(permission => {
                        if (permission === 'granted') {
                            new Notification(`Message from ${senderName}`, { body: messageText || '' });
                        }
                    });
                }
            }
        }

        async function translateText(text, target) {
            if (!text || target === 'none') return null;
            const cacheKey = `${target}::${text}`;
            if (chatTranslationCache.has(cacheKey)) {
                return chatTranslationCache.get(cacheKey);
            }
            try {
                const response = await fetch('https://libretranslate.de/translate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        q: text,
                        source: 'auto',
                        target,
                        format: 'text'
                    })
                });
                if (!response.ok) return null;
                const data = await response.json();
                const translated = data?.translatedText || null;
                if (translated) chatTranslationCache.set(cacheKey, translated);
                return translated;
            } catch (error) {
                return null;
            }
        }

        function openPeerModal(peerId) {
            const peer = peerPresence.get(peerId);
            if (!peer) return;
            activePeerModalId = peerId;
            document.getElementById('peer-modal-name').textContent = peer.name || 'Unnamed device';
            const connectedAt = peer.connectedAt || peer.lastSeen || Date.now();
            const duration = (peer.state === 'suspended' && peer.disconnectedAt)
                ? peer.disconnectedAt - connectedAt
                : Date.now() - connectedAt;
            document.getElementById('peer-modal-meta').textContent = `Connected: ${formatTimestamp(connectedAt)}`;
            document.getElementById('peer-connected-at').textContent = formatTimestamp(connectedAt);
            document.getElementById('peer-connected-duration').textContent = formatDuration(duration);

            const history = loadPeerHistory(peerId);
            const historyList = document.getElementById('peer-connection-history');
            historyList.innerHTML = '';
            if (history.length === 0) {
                const item = document.createElement('li');
                item.className = 'text-[11px] text-gray-400';
                item.textContent = 'No prior connections yet.';
                historyList.appendChild(item);
            } else {
                history.slice(-5).reverse().forEach(entry => {
                    const item = document.createElement('li');
                    item.className = 'bg-white border border-gray-200 rounded-lg p-2';
                    const endText = entry.disconnectedAt ? formatTimestamp(entry.disconnectedAt) : 'Active';
                    item.innerHTML = `<div><strong>Start:</strong> ${formatTimestamp(entry.connectedAt)}</div>
                        <div><strong>End:</strong> ${endText}</div>
                        <div><strong>Duration:</strong> ${formatDuration(entry.durationMs || (entry.disconnectedAt ? entry.disconnectedAt - entry.connectedAt : 0))}</div>`;
                    historyList.appendChild(item);
                });
            }

            const translationSelect = document.getElementById('peer-chat-translation');
            if (translationSelect) {
                translationSelect.value = chatTranslationTarget;
            }
            resetUnreadChat();
            renderPeerChat(peerId);
            toggleModal('peer', true);
        }

        function closePeerModal() {
            activePeerModalId = null;
            toggleModal('peer', false);
        }

        function renderPeerChat(peerId) {
            const chatHistory = loadPeerChat(peerId);
            const chatBox = document.getElementById('peer-chat-history');
            chatBox.innerHTML = '';
            chatHistory.forEach(entry => {
                const bubble = document.createElement('div');
                bubble.className = entry.from === 'local'
                    ? 'bg-blue-100 text-blue-800 p-2 rounded-lg text-xs ml-auto max-w-[85%]'
                    : 'bg-gray-200 text-gray-700 p-2 rounded-lg text-xs mr-auto max-w-[85%]';
                const nameLine = document.createElement('div');
                nameLine.className = 'font-semibold text-[10px] uppercase';
                nameLine.textContent = entry.from === 'local' ? 'You' : (entry.name || 'Peer');
                const messageLine = document.createElement('div');
                messageLine.className = 'grid grid-cols-1 gap-2';
                const originalColumn = document.createElement('div');
                const originalLabel = document.createElement('div');
                originalLabel.className = 'text-[10px] text-gray-400';
                originalLabel.textContent = 'Original';
                const originalText = document.createElement('div');
                originalText.textContent = entry.message || '';
                originalColumn.appendChild(originalLabel);
                originalColumn.appendChild(originalText);

                messageLine.appendChild(originalColumn);

                if (chatTranslationTarget !== 'none') {
                    const translatedColumn = document.createElement('div');
                    const translatedLabel = document.createElement('div');
                    translatedLabel.className = 'text-[10px] text-gray-400';
                    translatedLabel.textContent = `Translated (${chatTranslationTarget.toUpperCase()})`;
                    const translatedText = document.createElement('div');
                    translatedText.textContent = 'Translatingâ€¦';
                    translatedColumn.appendChild(translatedLabel);
                    translatedColumn.appendChild(translatedText);
                    messageLine.appendChild(translatedColumn);

                    translateText(entry.message || '', chatTranslationTarget).then(result => {
                        translatedText.textContent = result || 'Translation unavailable';
                    });
                }
                const timeLine = document.createElement('div');
                timeLine.className = 'text-[10px] text-gray-400 mt-1';
                timeLine.textContent = formatTimestamp(entry.ts);
                bubble.appendChild(nameLine);
                bubble.appendChild(messageLine);
                bubble.appendChild(timeLine);
                chatBox.appendChild(bubble);
            });
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        function recordPeerConnectionStart(peerId, ts) {
            const history = loadPeerHistory(peerId);
            history.push({ connectedAt: ts, disconnectedAt: null, durationMs: null });
            savePeerHistory(peerId, history);
        }

        function recordPeerConnectionEnd(peerId, ts) {
            const history = loadPeerHistory(peerId);
            const last = history[history.length - 1];
            if (last && !last.disconnectedAt) {
                last.disconnectedAt = ts;
                last.durationMs = ts - last.connectedAt;
                savePeerHistory(peerId, history);
            }
        }

        function getRelayLogSlotKey(index) {
            return `${RELAY_LOG_SLOT_PREFIX}${index}`;
        }

        function readRelayLogSlot(index) {
            const key = getRelayLogSlotKey(index);
            try {
                const raw = localStorage.getItem(key);
                return raw ? JSON.parse(raw) : null;
            } catch (_) {
                return null;
            }
        }

        function writeRelayLogSlot(index, slot) {
            const key = getRelayLogSlotKey(index);
            try {
                localStorage.setItem(key, JSON.stringify(slot));
            } catch (_) {}
        }

        function updateRelayLogMeta(lastEventTs) {
            try {
                const meta = {
                    updatedAt: Date.now(),
                    lastEventTs,
                    slotCount: RELAY_LOG_SLOT_COUNT,
                    slotDurationMs: RELAY_LOG_SLOT_DURATION_MS
                };
                localStorage.setItem(RELAY_LOG_META_KEY, JSON.stringify(meta));
            } catch (_) {}
        }

        function recordRelayEvent(rawEvent) {
            if (!rawEvent || !RELAY_LOGGABLE_TYPES.has(rawEvent.type)) return;
            let event;
            try {
                event = { ...rawEvent };
            } catch (_) {
                event = rawEvent;
            }
            const ts = Number.isFinite(event.ts) ? event.ts : Date.now();
            event.ts = ts;
            const slotStart = Math.floor(ts / RELAY_LOG_SLOT_DURATION_MS) * RELAY_LOG_SLOT_DURATION_MS;
            const slotIndex = Math.floor(ts / RELAY_LOG_SLOT_DURATION_MS) % RELAY_LOG_SLOT_COUNT;
            const slot = readRelayLogSlot(slotIndex);
            const nextSlot = (!slot || slot.start !== slotStart)
                ? { start: slotStart, events: [] }
                : slot;
            nextSlot.events.push(event);
            writeRelayLogSlot(slotIndex, nextSlot);
            updateRelayLogMeta(ts);
        }

        function createSeed() {
            if (crypto?.getRandomValues) {
                const arr = new Uint32Array(1);
                crypto.getRandomValues(arr);
                return arr[0];
            }
            return Math.floor(Math.random() * 2 ** 32);
        }

        function buildBloomPayload(rng) {
            const hue = random(0, 360, rng);
            const shapeRoll = rng();
            return {
                maxSize: random(30, 80, rng),
                hue,
                petals: Math.floor(random(5, 9, rng)),
                rotation: random(0, Math.PI * 2, rng),
                shape: shapeRoll > 0.6 ? 'pointed' : (shapeRoll > 0.3 ? 'round' : 'hybrid')
            };
        }

        function buildGrowingHeartPayload(rng) {
            return {
                maxSize: random(40, 90, rng),
                hue: random(0, 360, rng)
            };
        }

        function buildHeartCloudPayload(rng) {
            const colors = ["#ff0000", "#ff7f00", "#ffff00", "#00ff00", "#0000ff", "#4b0082", "#9400d3", "#ff1493"];
            const count = Math.floor(random(4, 12, rng));
            const hearts = [];
            for (let i = 0; i < count; i++) {
                hearts.push({
                    ox: random(-40, 40, rng),
                    oy: random(-40, 40, rng),
                    size: random(10, 25, rng),
                    color: colors[Math.floor(rng() * colors.length)],
                    rot: random(-0.2, 0.2, rng)
                });
            }
            return { hearts };
        }

        function buildTrailPayload(rng, trailType) {
            const hue = random(0, 360, rng);
            return {
                type: trailType,
                size: random(10, 20, rng),
                hue,
                color: `hsl(${hue},100%,60%)`,
                cometColor: `hsl(${random(200,260, rng)},100%,80%)`
            };
        }

        function updateSyncIndicator(mode) {
            if (!syncIndicator) return;
            if (mode === 'live') {
                syncIndicator.style.opacity = '0';
                return;
            }
            syncIndicator.style.opacity = '1';
        }

        
        
        function wakeAudio() {
            ZenAudio.warmUp();
            document.removeEventListener('touchstart', wakeAudio);
            document.removeEventListener('mousedown', wakeAudio);
        }
        document.addEventListener('touchstart', wakeAudio, {passive: false});
        document.addEventListener('mousedown', wakeAudio);

        function handleInputStart(x,y) { 
            ZenAudio.warmUp();
            document.getElementById('overlay').style.opacity='0'; 
            startX=x; startY=y; 
            dragStart=Date.now(); 
            isDragging=false; 
        }
        
        function spawnTap(x, y, options = {}) {
            const {
                entType = 'Bloom',
                idx = ZenAudio.getFreqIndex(y, height),
                isDouble = false,
                trackTelemetry = false,
                wordText,
                wordColor,
                bloomPayload,
                heartPayload,
                cloudPayload
            } = options;
            let ent;
            if (config.spriteMode === 'fireworks') {
                const burstCount = 24;
                for (let i = 0; i < burstCount; i += 1) {
                    const angle = (Math.PI * 2 * i) / burstCount;
                    const speed = random(1.5, 3.5);
                    particles.push(new Particle(x, y, `hsla(${random(0,360)},70%,70%,1)`, {
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed
                    }));
                }
            } else if (config.spriteMode === 'shapes') {
                ent = new ShapePulse(x, y, bloomPayload || {});
                visualEntities.push(ent);
            } else {
                if (entType === 'GrowingHeart') ent = new GrowingHeart(x, y, heartPayload || {});
                else if (entType === 'HeartBloom') ent = new HeartBloom(x, y, null, bloomPayload || {});
                else ent = new Bloom(x, y, null, bloomPayload || {});
                visualEntities.push(ent);
            }

            wordEntities.push(new Word(x, y - 30, wordText, { color: wordColor }));

            pendingAudioEvents.push({
                type: 'pluck',
                freq: ZenAudio.scale[idx],
                volume: 0.3
            });

            if (trackTelemetry) {
                window.telemetryStats.taps++;
                appendSessionLog('tap', `Tap at ${Math.round(x)}, ${Math.round(y)}${isDouble ? ' [double]' : ''}`);
            }

            if (isDouble && config.spriteMode === 'flowers') {
                visualEntities.push(new HeartCloud(x, y, cloudPayload || {}));
                pendingAudioEvents.push({
                    type: 'chord',
                    baseIdx: idx
                });
                if (trackTelemetry) {
                    window.telemetryStats.drags++;
                }
            }
            return ent;
        }

        function spawnDrag(x, y, options = {}) {
            const { trailType = config.currentTrail, idx = ZenAudio.getFreqIndex(y, height), trailPayload } = options;
            const resolvedType = trailPayload?.type || trailType;
            if (config.spriteMode === 'fireworks') {
                particles.push(new Particle(x, y, `hsla(${random(0,360)},70%,70%,1)`));
            } else if (config.spriteMode === 'shapes') {
                visualEntities.push(new ShapePulse(x, y, trailPayload || {}));
            } else {
                visualEntities.push(new TrailBase(x, y, resolvedType, trailPayload || {}));
            }
            pendingAudioEvents.push({
                type: 'pluck',
                freq: ZenAudio.scale[idx],
                volume: 0.1
            });
        }

        function handleInputMove(x,y) {
            if(startX === null || startY === null) return;
            if(Math.sqrt((x-startX)**2 + (y-startY)**2) > 10) {
                isDragging=true;
                
                if(config.spriteMode === 'flowers' && Date.now() - config.lastTrailSwitch > 10000) {
                    const options = ['â™¥', 'Comet', 'â˜ï¸', 'â­'];
                    if (config.currentTrail !== 'â™¥' && Math.random() > 0.4) {
                        config.currentTrail = 'â™¥';
                    } else {
                        config.currentTrail = options[Math.floor(Math.random() * options.length)];
                    }
                    config.lastTrailSwitch = Date.now();
                }

                const idx = ZenAudio.getFreqIndex(y, height);
                const trailSeed = createSeed();
                const trailRng = createSeededRng(trailSeed);
                const trailPayload = buildTrailPayload(trailRng, config.currentTrail);
                spawnDrag(x, y, { trailType: config.currentTrail, idx, trailPayload });

                if(Date.now()-lastDragSound > 40) { 
                    pendingAudioEvents.push({
                        type: 'pluck',
                        freq: ZenAudio.scale[idx],
                        volume: 0.1
                    });
                    lastDragSound=Date.now(); 
                }

                if (Date.now() - lastRelayDragSend > RELAY_DRAG_THROTTLE_MS) {
                    sendRelayMessage({
                        type: 'drag',
                        x: x / width,
                        y: y / height,
                        trail: config.currentTrail,
                        trailPayload,
                        transient: true
                    });
                    lastRelayDragSend = Date.now();
                }
            }
        }

        function handleInputEnd(x,y) {
            const now = Date.now();
            if(isDragging) { 
                registerInput('S'); 
                checkDragUnlock(now-dragStart); 
                appendSessionLog('drag', `Drag to ${Math.round(x)}, ${Math.round(y)} (${config.currentTrail})`);
            } else {
                const idx = ZenAudio.getFreqIndex(y, height);
                const seed = createSeed();
                const rng = createSeededRng(seed);
                const rnd = rng();
                const entType = (foundEggs.includes(3) && rnd > 0.7)
                    ? 'GrowingHeart'
                    : (foundEggs.includes(3) && rnd > 0.5)
                        ? 'HeartBloom'
                        : 'Bloom';

                registerInput('T');

                const isNearLastTap = lastTapX !== null && lastTapY !== null && Math.hypot(x - lastTapX, y - lastTapY) <= DOUBLE_TAP_DISTANCE;
                const isDoubleTap = (now - lastTap) < DOUBLE_TAP_WINDOW && isNearLastTap;

                const wordText = getRandomWord(rng);
                const wordColor = themes[config.currentThemeIndex].text;
                const bloomPayload = entType === 'Bloom' || entType === 'HeartBloom' ? buildBloomPayload(rng) : null;
                const heartPayload = entType === 'GrowingHeart' ? buildGrowingHeartPayload(rng) : null;
                const cloudPayload = isDoubleTap ? buildHeartCloudPayload(rng) : null;

                const ent = spawnTap(x, y, { entType, idx, isDouble: isDoubleTap, trackTelemetry: true, wordText, wordColor, bloomPayload, heartPayload, cloudPayload });
                sendRelayMessage({
                    type: 'tap',
                    x: x / width,
                    y: y / height,
                    double: isDoubleTap,
                    entType: ent?.constructor?.name || 'Bloom',
                    word: wordText,
                    wordColor,
                    bloomPayload,
                    heartPayload,
                    cloudPayload,
                    seed
                });
                lastTap = now;
                lastTapX = x;
                lastTapY = y;
            }
            startX=null; startY=null; isDragging=false;
        }
        
        canvas.addEventListener('mousedown',e=>handleInputStart(e.clientX,e.clientY));
        canvas.addEventListener('mousemove',e=>{if(startX !== null)handleInputMove(e.clientX,e.clientY)});
        canvas.addEventListener('mouseup',e=>handleInputEnd(e.clientX,e.clientY));
        canvas.addEventListener('touchstart',e=>{e.preventDefault();handleInputStart(e.touches[0].clientX,e.touches[0].clientY)},{passive:false});
        canvas.addEventListener('touchmove',e=>{e.preventDefault();if(startX !== null)handleInputMove(e.touches[0].clientX,e.touches[0].clientY)},{passive:false});
        canvas.addEventListener('touchend',e=>{e.preventDefault();if(e.changedTouches.length)handleInputEnd(e.changedTouches[0].clientX,e.changedTouches[0].clientY)});

        function spawnRemoteTap(x, y, options = {}) {
            const {
                entType = 'Bloom',
                isDouble = false,
                wordText,
                wordColor,
                bloomPayload,
                heartPayload,
                cloudPayload
            } = options;
            let ent;
            if (config.spriteMode === 'fireworks') {
                const burstCount = 24;
                for (let i = 0; i < burstCount; i += 1) {
                    const angle = (Math.PI * 2 * i) / burstCount;
                    const speed = random(1.5, 3.5);
                    particles.push(new Particle(x, y, `hsla(${random(0,360)},70%,70%,1)`, {
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed
                    }));
                }
            } else if (config.spriteMode === 'shapes') {
                ent = new ShapePulse(x, y, bloomPayload || {});
                visualEntities.push(ent);
            } else {
                if (entType === 'GrowingHeart') ent = new GrowingHeart(x, y, heartPayload || {});
                else if (entType === 'HeartBloom') ent = new HeartBloom(x, y, null, bloomPayload || {});
                else ent = new Bloom(x, y, null, bloomPayload || {});
                visualEntities.push(ent);
            }
            wordEntities.push(new Word(x, y - 30, wordText, { color: wordColor }));

            const idx = ZenAudio.getFreqIndex(y, height);
            const baseVolume = 0.3;
            const volume = Date.now() < remoteEntryDampenUntil ? baseVolume * 0.45 : baseVolume;
            pendingAudioEvents.push({
                type: 'pluck',
                freq: ZenAudio.scale[idx],
                volume
            });

            if (isDouble && config.spriteMode === 'flowers') {
                visualEntities.push(new HeartCloud(x, y, cloudPayload || {}));
                pendingAudioEvents.push({
                    type: 'chord',
                    baseIdx: idx
                });
            }
        }

        function spawnRemoteDrag(x, y, trail, trailPayload) {
            const resolvedType = trailPayload?.type || trail || config.currentTrail;
            if (config.spriteMode === 'fireworks') {
                particles.push(new Particle(x, y, `hsla(${random(0,360)},70%,70%,1)`));
            } else if (config.spriteMode === 'shapes') {
                visualEntities.push(new ShapePulse(x, y, trailPayload || {}));
            } else {
                visualEntities.push(new TrailBase(x, y, resolvedType, trailPayload || {}));
            }
            if (Date.now() - lastRemoteDragSound > 60) {
                const idx = ZenAudio.getFreqIndex(y, height);
                const baseVolume = 0.1;
                const volume = Date.now() < remoteEntryDampenUntil ? baseVolume * 0.6 : baseVolume;
                pendingAudioEvents.push({
                    type: 'pluck',
                    freq: ZenAudio.scale[idx],
                    volume
                });
                lastRemoteDragSound = Date.now();
            }
        }

        function buildSyncState() {
            return {
                themeIndex: config.currentThemeIndex,
                useGradient: config.useGradient,
                backgroundImage: config.backgroundImageData || null,
                customWords: config.customWords || [],
                currentScale: config.currentScale,
                spriteMode: config.spriteMode
            };
        }

        function shouldRelaxRemoteClock(reason) {
            return ['focus', 'visibility', 'reconnect', 'hello', 'startup', 'snapshot'].includes(reason);
        }

        async function fetchSnapshot(reason = 'startup') {
            const url = new URL(RELAY_SIGNAL_HTTP_URL);
            url.searchParams.set('session', RELAY_SESSION_ID);
            url.searchParams.set('client', RELAY_CLIENT_ID);
            url.searchParams.set('snapshot', '1');
            try {
                const res = await fetch(url.toString());
                relayHandshake.snapshotFetched = true;
                if (!res.ok) return;
                const snapshot = await res.json();
                if (snapshot?.state) {
                    relayHandshake.snapshotFound = true;
                    applySyncState(snapshot.state, snapshot.stateTs || snapshot.ts, {
                        relaxLocalClock: true,
                        source: reason
                    });
                    completeRelayHandshake('snapshot');
                }
            } catch (_) {}
        }

        function sendSnapshot(reason = 'snapshot') {
            const stateTs = syncState.lastLocalStateTs || Date.now();
            const state = buildSyncState();
            sendRelayMessage({ type: 'snapshot', state, stateTs, reason });
        }

        function queueSnapshot(reason = 'debounced') {
            if (snapshotTimer) clearTimeout(snapshotTimer);
            snapshotTimer = setTimeout(() => {
                snapshotTimer = null;
                sendSnapshot(reason);
            }, SNAPSHOT_DEBOUNCE_MS);
        }

        function flushSnapshot(reason = 'pagehide') {
            if (!localStateDirty && !snapshotTimer) return;
            if (snapshotTimer) {
                clearTimeout(snapshotTimer);
                snapshotTimer = null;
            }
            sendSnapshot(reason);
            localStateDirty = false;
        }

        function applySyncState(state, stateTs = Date.now(), options = {}) {
            if (!state) return;
            const relaxLocalClock = Boolean(options.relaxLocalClock);
            const effectiveStateTs = Number.isFinite(stateTs) ? stateTs : Date.now();
            if (!relaxLocalClock && effectiveStateTs && effectiveStateTs <= syncState.lastStateTs) return;
            if (!relaxLocalClock && effectiveStateTs && syncState.lastLocalStateTs && effectiveStateTs < syncState.lastLocalStateTs) return;
            syncState.lastStateTs = effectiveStateTs;
            remoteStateApplied = true;
            if (effectiveStateTs) {
                syncState.lastLocalStateTs = relaxLocalClock
                    ? effectiveStateTs
                    : Math.max(syncState.lastLocalStateTs, effectiveStateTs);
                localStorage.setItem('peace_state_ts', String(syncState.lastLocalStateTs));
            }
            if (options.source) {
                localStateDirty = false;
            }

            if (typeof state.themeIndex === 'number') {
                config.currentThemeIndex = state.themeIndex % themes.length;
            }

            if (Array.isArray(state.customWords)) {
                const customWordsInput = document.getElementById('custom-words');
                config.customWords = state.customWords.filter(Boolean);
                if (customWordsInput) {
                    customWordsInput.value = config.customWords.join(', ');
                    localStorage.setItem('peace_words', customWordsInput.value);
                }
            }

            if (state.backgroundImage) {
                const img = new Image();
                img.onload = () => {
                    config.backgroundImage = img;
                    config.useGradient = false;
                    config.backgroundImageData = state.backgroundImage;
                    saveBackgroundImage(state.backgroundImage);
                };
                img.src = state.backgroundImage;
            } else if (state.useGradient !== undefined) {
                config.useGradient = state.useGradient;
                if (state.useGradient) {
                    config.backgroundImage = null;
                    config.backgroundImageData = null;
                    clearBackgroundImage();
                }
            }

            if (state.currentScale && scales[state.currentScale]) {
                config.currentScale = state.currentScale;
                const scaleSelector = document.getElementById('scale-selector');
                if (scaleSelector) scaleSelector.value = config.currentScale;
                ZenAudio.changeScale(config.currentScale);
                localStorage.setItem('peace_scale', config.currentScale);
            }

            if (typeof state.spriteMode === 'string') {
                const spriteSelect = document.getElementById('sprite-mode');
                config.spriteMode = state.spriteMode;
                if (spriteSelect) spriteSelect.value = config.spriteMode;
                localStorage.setItem(SPRITE_MODE_STORAGE_KEY, config.spriteMode);
            }
        }

        function sendSyncState(reason = 'update') {
            if (reason === 'init' && syncState.initialSent) return;
            const stateTs = syncState.lastLocalStateTs || Date.now();
            const state = buildSyncState();
            sendRelayMessage({ type: 'state', state, stateTs, reason });
            syncState.initialSent = true;
        }

        function startRelayKeepalive() {
            if (relayKeepaliveTimer) return;
            relayKeepaliveTimer = setInterval(() => {
                sendRelayMessage({ type: 'ping' });
            }, RELAY_KEEPALIVE_MS);
        }

        function getLocalPresenceState() {
            return document.visibilityState === 'visible' ? 'active' : 'suspended';
        }

        function sendPresence(reason = 'interval') {
            const state = getLocalPresenceState();
            localPresenceState = state;
            sendRelayMessage({
                type: 'presence',
                state,
                name: joinState.name || undefined,
                reason
            });
        }

        function startPresenceUpdates() {
            if (!presenceTimer) {
                presenceTimer = setInterval(() => {
                    sendPresence('interval');
                }, RELAY_PRESENCE_INTERVAL_MS);
            }
            if (!presenceRenderTimer) {
                presenceRenderTimer = setInterval(renderSessionStatus, SESSION_STATUS_RENDER_MS);
            }
            sendPresence('start');
            renderSessionStatus();
        }

        function renderSessionStatus() {
            if (!sessionStatusList) return;
            const peers = Array.from(peerPresence.values());
            const now = Date.now();
            sessionStatusList.innerHTML = '';

            if (peers.length === 0) {
                const emptyItem = document.createElement('li');
                emptyItem.className = 'text-[11px] text-gray-400';
                emptyItem.textContent = 'No peers yet.';
                sessionStatusList.appendChild(emptyItem);
                return;
            }

            peers
                .sort((a, b) => ((a.name || 'Unnamed device').localeCompare(b.name || 'Unnamed device')))
                .forEach(peer => {
                    const isStale = now - peer.lastSeen > RELAY_PRESENCE_STALE_MS;
                    if (isStale && peer.state !== 'suspended') {
                        peer.state = 'suspended';
                        peer.disconnectedAt = now;
                        recordPeerConnectionEnd(peer.id, now);
                    }
                    const status = isStale ? 'suspended' : (peer.state || 'active');
                    const dotClass = status === 'active' ? 'bg-emerald-400' : 'bg-amber-400';
                    const statusLabel = status === 'active' ? 'Active' : 'Suspended';
                    const displayName = peer.name?.trim() || 'Unnamed device';

                    const row = document.createElement('li');
                    row.className = 'flex items-center justify-between gap-2 text-xs text-gray-600';

                    const left = document.createElement('div');
                    left.className = 'flex items-center gap-2 min-w-0';

                    const dot = document.createElement('span');
                    dot.className = `w-2.5 h-2.5 rounded-full ${dotClass}`;

                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'font-medium text-gray-700 truncate';
                    nameSpan.textContent = displayName;
                    nameSpan.title = 'View details';
                    nameSpan.addEventListener('click', () => openPeerModal(peer.id));

                    const timeSpan = document.createElement('span');
                    timeSpan.className = 'text-[10px] text-gray-400';
                    timeSpan.textContent = `Connected ${formatTimestamp(peer.connectedAt || peer.lastSeen)}`;

                    left.appendChild(dot);
                    const nameBlock = document.createElement('div');
                    nameBlock.className = 'flex flex-col min-w-0';
                    nameBlock.appendChild(nameSpan);
                    nameBlock.appendChild(timeSpan);
                    left.appendChild(nameBlock);

                    const right = document.createElement('div');
                    right.className = 'flex items-center gap-2 shrink-0';

                    const statusSpan = document.createElement('span');
                    statusSpan.className = 'text-[10px] uppercase tracking-wider text-gray-400';
                    statusSpan.textContent = statusLabel;

                    const removeBtn = document.createElement('button');
                    removeBtn.type = 'button';
                    removeBtn.className = 'text-[11px] text-gray-400 hover:text-gray-700 transition';
                    removeBtn.title = 'Clear';
                    removeBtn.textContent = 'âœ•';
                    removeBtn.addEventListener('click', () => {
                        peerPresence.delete(peer.id);
                        renderSessionStatus();
                    });

                    right.appendChild(statusSpan);
                    right.appendChild(removeBtn);

                    row.appendChild(left);
                    row.appendChild(right);
                    sessionStatusList.appendChild(row);
                });
        }

        function handleRelayMessage(message) {
            if (!message || message.session !== RELAY_SESSION_ID) return;
            if (message.from && message.from === RELAY_CLIENT_ID) return;
            if (message.to && message.to !== RELAY_CLIENT_ID) return;

            recordRelayEvent(message);

            if (message.type === 'presence') {
                const existing = peerPresence.get(message.from) || { id: message.from };
                const now = message.ts || Date.now();
                const wasSuspended = existing.state === 'suspended';
                peerPresence.set(message.from, {
                    id: message.from,
                    name: message.name || existing.name || null,
                    state: message.state || existing.state || 'active',
                    lastSeen: now,
                    connectedAt: existing.connectedAt || now,
                    disconnectedAt: existing.disconnectedAt || null
                });
                if (!existing.connectedAt) {
                    recordPeerConnectionStart(message.from, now);
                } else if (wasSuspended && message.state === 'active') {
                    const refreshed = peerPresence.get(message.from);
                    refreshed.connectedAt = now;
                    refreshed.disconnectedAt = null;
                    recordPeerConnectionStart(message.from, now);
                } else if (message.state === 'suspended' && existing.state !== 'suspended') {
                    const refreshed = peerPresence.get(message.from);
                    refreshed.disconnectedAt = now;
                    recordPeerConnectionEnd(message.from, now);
                }
                renderSessionStatus();
                return;
            }

            if (message.type === 'leave') {
                const existing = peerPresence.get(message.from);
                const now = message.ts || Date.now();
                if (existing) {
                    existing.state = 'suspended';
                    existing.disconnectedAt = now;
                    recordPeerConnectionEnd(message.from, now);
                }
                renderSessionStatus();
                return;
            }

            if (message.type === 'hello') {
                remoteEntryDampenUntil = Date.now() + REMOTE_ENTRY_DAMPEN_MS;
                ZenAudio.softenEntry();
                sendSyncState('hello');
                return;
            }

            if (message.type === 'state') {
                const relaxLocalClock = shouldRelaxRemoteClock(message.reason || 'state');
                applySyncState(message.state, message.stateTs || message.ts, {
                    relaxLocalClock,
                    source: message.reason
                });
                return;
            }
            if (message.type === 'snapshot') {
                const relaxLocalClock = shouldRelaxRemoteClock(message.reason || 'snapshot');
                applySyncState(message.state, message.stateTs || message.ts, { relaxLocalClock, source: message.reason });
                completeRelayHandshake('snapshot');
                return;
            }
            if (message.type === 'ping') {
                return;
            }

            if (message.type === 'chat') {
                const peerId = message.from;
                const chatHistory = loadPeerChat(peerId);
                const senderName = message.name || peerPresence.get(peerId)?.name || 'Peer';
                chatHistory.push({
                    from: 'peer',
                    name: senderName,
                    message: message.text || '',
                    ts: message.ts || Date.now()
                });
                savePeerChat(peerId, chatHistory);
                handleIncomingChatAlert(senderName, message.text || '');
                if (activePeerModalId === peerId) {
                    renderPeerChat(peerId);
                }
                return;
            }

            const x = Math.max(0, Math.min(1, message.x ?? 0.5)) * width;
            const y = Math.max(0, Math.min(1, message.y ?? 0.5)) * height;
            document.getElementById('overlay').style.opacity='0';

            if (message.type === 'tap') {
                addPresencePulse();
                spawnRemoteTap(x, y, {
                    entType: message.entType || 'Bloom',
                    isDouble: Boolean(message.double),
                    wordText: message.word,
                    wordColor: message.wordColor,
                    bloomPayload: message.bloomPayload,
                    heartPayload: message.heartPayload,
                    cloudPayload: message.cloudPayload
                });
            } else if (message.type === 'drag') {
                addPresencePulse();
                spawnRemoteDrag(x, y, message.trail, message.trailPayload);
            }
        }

        function sendRelayMessage(payload) {
            const message = {
                session: RELAY_SESSION_ID,
                from: RELAY_CLIENT_ID,
                ts: Date.now(),
                ...payload
            };
            recordRelayEvent(message);
            if (relayState.ws && relayState.ws.readyState === WebSocket.OPEN) {
                relayState.ws.send(JSON.stringify(message));
                updateSyncIndicator('live');
                return;
            }
            relayQueue.push(message);
            updateSyncIndicator('connecting');
        }

        function flushRelayQueue() {
            if (!relayState.ws || relayState.ws.readyState !== WebSocket.OPEN) return;
            while (relayQueue.length) {
                const queued = relayQueue.shift();
                relayState.ws.send(JSON.stringify(queued));
            }
        }

        function scheduleRelayReconnect() {
            if (relayState.reconnectTimer) return;
            const delay = Math.min(RELAY_RECONNECT_MAX_MS, RELAY_RECONNECT_BASE_MS * (2 ** relayState.reconnectAttempts));
            relayState.reconnectAttempts += 1;
            relayState.reconnectTimer = setTimeout(() => {
                relayState.reconnectTimer = null;
                startRelayHandshake('reconnect');
            }, delay);
        }

        function closeNonOpenRelaySocket(reason = 'refresh') {
            if (relayState.ws && relayState.ws.readyState !== WebSocket.OPEN) {
                relayState.ws.close(4000, reason);
                relayState.ws = null;
                clearTimeout(relayState.connectTimeoutTimer);
            }
        }

        function scheduleRelayConnectTimeout(ws) {
            clearTimeout(relayState.connectTimeoutTimer);
            relayState.connectTimeoutTimer = setTimeout(() => {
                if (relayState.ws === ws && ws.readyState === WebSocket.CONNECTING) {
                    ws.close(4001, 'connect-timeout');
                }
            }, RELAY_CONNECT_TIMEOUT_MS);
        }

        function connectRelay() {
            if (relayState.ws && (relayState.ws.readyState === WebSocket.OPEN || relayState.ws.readyState === WebSocket.CONNECTING)) {
                return;
            }
            const url = new URL(RELAY_SIGNAL_WS_URL);
            url.searchParams.set('session', RELAY_SESSION_ID);
            url.searchParams.set('client', RELAY_CLIENT_ID);
            relayState.ws = new WebSocket(url.toString());
            scheduleRelayConnectTimeout(relayState.ws);
            updateSyncIndicator('connecting');
            relayState.ws.onopen = () => {
                updateSyncIndicator('live');
                relayState.reconnectAttempts = 0;
                clearTimeout(relayState.connectTimeoutTimer);
                flushRelayQueue();
                sendRelayMessage({ type: 'reattach', reason: relayHandshake.reason || 'open', transient: true });
                sendRelayMessage({ type: 'hello', reason: relayHandshake.reason || 'open' });
            };
            relayState.ws.onmessage = event => {
                try {
                    handleRelayMessage(JSON.parse(event.data));
                } catch (_) {}
            };
            relayState.ws.onclose = () => {
                clearTimeout(relayState.connectTimeoutTimer);
                relayState.ws = null;
                updateSyncIndicator('connecting');
                scheduleRelayReconnect();
            };
            relayState.ws.onerror = () => {
                if (relayState.ws) relayState.ws.close();
            };
        }
        
        function startRelayHandshake(reason = 'startup') {
            relayHandshake.reason = reason;
            if (!relayHandshake.active) {
                relayHandshake.active = true;
                relayHandshake.snapshotApplied = false;
                relayHandshake.snapshotFound = false;
                relayHandshake.snapshotFetched = false;
            }
            closeNonOpenRelaySocket(reason);
            connectRelay();
            fetchSnapshot(reason);
            clearTimeout(relayHandshake.timeoutTimer);
            relayHandshake.timeoutTimer = setTimeout(() => {
                completeRelayHandshake('timeout');
            }, 5000);
        }

        function completeRelayHandshake(source = 'snapshot') {
            if (!relayHandshake.active) return;
            relayHandshake.active = false;
            relayHandshake.snapshotApplied = source === 'snapshot';
            clearTimeout(relayHandshake.timeoutTimer);
            startRelayKeepalive();
            startPresenceUpdates();
            sendRelayMessage({ type: 'reattach', reason: source, transient: true });
            sendRelayMessage({ type: 'hello', reason: source });
            if (localStateDirty || (relayHandshake.snapshotFetched && !relayHandshake.snapshotFound)) {
                queueSnapshot('handshake');
            }
        }

        const rhythmSequences = [
            { code: "TTT", id: 1, desc: "Tap Tap Tap", title: "Jewel Core" }, 
            { code: "TTS", id: 2, desc: "Tap Tap Swipe", title: "Gold Filigree" }, 
            { code: "TST", id: 3, desc: "Tap Swipe Tap", title: "Amour Bloom & Heart 3D" }, 
            { code: "SST", id: 4, desc: "Swipe Swipe Tap", title: "Dimension Heart" }, 
            { code: "TTTT", id: 5, desc: "Tap Tap Tap Tap", title: "Stardust Legacy" }, 
            { code: "SS", id: 6, desc: "Swipe Swipe", title: "Removed (Joy)" },
            { code: "TSTS", id: 7, desc: "Tap Swipe Tap Swipe", title: "Secret 7" }, 
            { code: "STST", id: 8, desc: "Swipe Tap Swipe Tap", title: "Secret 8" }, 
            { code: "TSS", id: 9, desc: "Tap Swipe Swipe", title: "Secret 9" }, 
            { code: "SSS", id: 10, desc: "Swipe Swipe Swipe", title: "Secret 10" }
        ];

        function registerInput(char) {
            inputBuffer += char; if(inputBuffer.length>5) inputBuffer=inputBuffer.slice(-5);
            rhythmSequences.forEach(seq => { if(inputBuffer.endsWith(seq.code)) triggerUnlock(seq.id); });
        }
        function checkDragUnlock(dur) {
            const sec = 10 + Math.floor(dur/1000) - 1;
            if(sec>10 && sec<=20) triggerUnlock(sec);
        }
        function triggerUnlock(id) {
            inputBuffer="";
            if(!foundEggs.includes(id)) {
                foundEggs.push(id); localStorage.setItem('peace_egg_ids', JSON.stringify(foundEggs));
                
                let b = new Bloom(width/2, height/2, 200);
                if(id===3) b = new GrowingHeart(width/2, height/2); 
                visualEntities.push(b);
                
                window.telemetryStats.secrets++;
                appendSessionLog('secret', `Unlocked ${id}`);

                updateSecretsUI();
            }
        }

        function drawBackground(ctx, img, cw, ch) {
            if (!img.complete || img.naturalWidth === 0) return;
            const scale = Math.max(cw / img.width, ch / img.height);
            const x = (cw / 2) - (img.width / 2) * scale;
            const y = (ch / 2) - (img.height / 2) * scale;
            ctx.drawImage(img, x, y, img.width * scale, img.height * scale);
        }

        const TARGET_FRAME_MS = 1000 / 60;
        let lastFrameTime = performance.now();

        function loop(timestamp) {
            const delta = timestamp - lastFrameTime;

            if (delta >= TARGET_FRAME_MS) {
                lastFrameTime = timestamp - (delta % TARGET_FRAME_MS);
                
                if (ZenAudio.ctx && pendingAudioEvents.length > 0) {
                    const audioTime = ZenAudio.ctx.currentTime;
                    
                    pendingAudioEvents.forEach(event => {
                        if (event.type === 'pluck') {
                            ZenAudio.playPluckScheduled(event.freq, event.volume, audioTime);
                        } else if (event.type === 'chord') {
                            ZenAudio.playChord(event.baseIdx, audioTime);
                        }
                    });
                    
                    pendingAudioEvents = [];
                }
                
                if(config.useGradient || !config.backgroundImage) {
                    const t=themes[config.currentThemeIndex]; const g=ctx.createLinearGradient(0,0,0,height);
                    g.addColorStop(0,t.bg[0]); g.addColorStop(1,t.bg[1]); ctx.fillStyle=g; ctx.fillRect(0,0,width,height);
                } else {
                    drawBackground(ctx, config.backgroundImage, width, height);
                }

                for(let i=visualEntities.length-1; i>=0; i--) { visualEntities[i].update(); if(visualEntities[i].isDead()) visualEntities.splice(i,1); }
                for(let i=wordEntities.length-1; i>=0; i--) { wordEntities[i].update(); if(wordEntities[i].isDead()) wordEntities.splice(i,1); }
                for(let i=particles.length-1; i>=0; i--) { particles[i].update(); particles[i].draw(ctx); if(particles[i].isDead()) particles.splice(i,1); }
                for(let i=presencePulses.length-1; i>=0; i--) { presencePulses[i].update(); if(presencePulses[i].isDead()) presencePulses.splice(i,1); }

                visualEntities.forEach(e => e.draw(ctx));
                wordEntities.forEach(w => w.draw(ctx));
                presencePulses.forEach(p => p.draw(ctx));

                document.getElementById('clock').innerText = new Date().toLocaleTimeString();
            }

            requestAnimationFrame(loop);
        }

        const bgInput=document.getElementById('bg-upload-input');
        
        document.getElementById('apply-bg-btn').addEventListener('click', ()=>{
            const f=bgInput.files[0]; if(!f){alert("Please select an image file first.");return;}
            const objectUrl = URL.createObjectURL(f);
            const i=new Image(); 
            i.onload=()=>{
                config.backgroundImage=i;
                config.useGradient=false;
                config.backgroundImageData=null;
                URL.revokeObjectURL(objectUrl);
            };
            i.onerror=()=>URL.revokeObjectURL(objectUrl);
            i.src=objectUrl;
            appendSessionLog('background', 'Applied custom background.');

            const r=new FileReader(); 
            r.onload=e=>{ 
                const dataUrl = e.target.result;
                compressBackgroundDataUrl(dataUrl).then(compressedDataUrl => {
                    config.backgroundImageData = compressedDataUrl;
                    markLocalStateChanged();
                    sendSyncState('background');
                    saveBackgroundImage(compressedDataUrl);
                });
            }; 
            r.readAsDataURL(f);
        });
        
        document.getElementById('reset-bg-btn').addEventListener('click', ()=>{ 
            clearBackgroundImage(); 
            config.useGradient=true; 
            config.backgroundImage=null; 
            config.backgroundImageData=null;
            appendSessionLog('background', 'Background reset to gradient.');
            markLocalStateChanged();
            sendSyncState('background-reset');
        });
        loadBackgroundImage().then(dataUrl => {
            if (!dataUrl) return;
            if (remoteStateApplied) return;
            const i=new Image();
            i.onload=()=>{
                config.backgroundImage=i;
                config.useGradient=false;
                config.backgroundImageData=dataUrl;
                sendSyncState('background-load');
                queueSnapshot('background-load');
            };
            i.src=dataUrl;
        });

        const panel=document.getElementById('settings-panel');
        document.getElementById('settings-trigger').onclick = ()=>panel.classList.remove('translate-x-full');
        document.getElementById('close-btn').onclick = ()=>panel.classList.add('translate-x-full');
        document.getElementById('audio-toggle').onchange=e=>{
            ZenAudio.enabled=e.target.checked;
            appendSessionLog('audio', `Audio ${ZenAudio.enabled ? 'on' : 'muted'}.`);
        };
        
        document.getElementById('decay-slider').oninput=e=>config.decayValue=[0,0.002,0.005,0.01,0.02,0.05][e.target.value];
        document.getElementById('trail-slider').oninput=e=>{
            const val = parseInt(e.target.value);
            const decays = [0.1, 0.08, 0.06, 0.04, 0.02, 0.01, 0.008, 0.005, 0.002, 0.0005];
            const speeds = [3.0, 2.5, 2.0, 1.5, 1.0, 0.8, 0.6, 0.4, 0.2, 0.1];
            config.trailDecay = decays[val-1];
            config.trailSpeed = speeds[val-1];
        };
        document.getElementById('speed-slider').oninput=e=>config.speedMultiplier=0.2+(e.target.value/100)*1.8;
        
        document.getElementById('theme-btn').onclick=()=>{
            config.currentThemeIndex=(config.currentThemeIndex+1)%themes.length;
            markLocalStateChanged();
            sendSyncState('theme');
        };
        document.getElementById('clear-btn').onclick=()=>{visualEntities=[];wordEntities=[];particles=[];};
        document.getElementById('save-btn').onclick=()=>{const a=document.createElement('a');a.download='garden.png';a.href=canvas.toDataURL();a.click();};
        const scaleSelector = document.getElementById('scale-selector');
        if (localStorage.getItem('peace_scale')) {
            config.currentScale = localStorage.getItem('peace_scale');
            scaleSelector.value = config.currentScale;
            ZenAudio.changeScale(config.currentScale);
        }
        scaleSelector.onchange = (e) => {
            config.currentScale = e.target.value;
            localStorage.setItem('peace_scale', config.currentScale);
            ZenAudio.changeScale(config.currentScale);
            markLocalStateChanged();
            sendSyncState('scale');
        };

        const spriteModeSelect = document.getElementById('sprite-mode');
        if (spriteModeSelect) {
            const storedSpriteMode = localStorage.getItem(SPRITE_MODE_STORAGE_KEY);
            if (storedSpriteMode) {
                config.spriteMode = storedSpriteMode;
            }
            spriteModeSelect.value = config.spriteMode;
            spriteModeSelect.addEventListener('change', (event) => {
                config.spriteMode = event.target.value;
                localStorage.setItem(SPRITE_MODE_STORAGE_KEY, config.spriteMode);
                markLocalStateChanged();
                sendSyncState('sprite');
            });
        }

        function markLocalStateChanged() {
            syncState.lastLocalStateTs = Date.now();
            localStorage.setItem('peace_state_ts', String(syncState.lastLocalStateTs));
            localStateDirty = true;
            queueSnapshot('local-change');
        }

        const modals = {
            secrets: document.getElementById('secrets-modal'),
            peer: document.getElementById('peer-modal')
        };

        function toggleModal(id, show) {
            const el = modals[id];
            const content = el.querySelector('.modal-content') || el.querySelector('div');
            if(show) { 
                if (id === 'secrets') updateSecretsUI();
                el.classList.remove('invisible'); el.classList.add('visible');
                content.classList.remove('scale-out'); content.classList.add('scale-in');
                panel.classList.add('translate-x-full'); 
            } else { 
                el.classList.remove('visible'); el.classList.add('invisible');
                content.classList.remove('scale-in'); content.classList.add('scale-out');
            }
        }

        localPresenceState = getLocalPresenceState();
        document.addEventListener('visibilitychange', () => {
            localPresenceState = getLocalPresenceState();
            sendPresence('visibility');
            renderSessionStatus();
            if (document.hidden) {
                return;
            }
            resetUnreadChat();
            startRelayHandshake('visibility');
        });
        window.addEventListener('focus', () => {
            localPresenceState = getLocalPresenceState();
            sendPresence('focus');
            renderSessionStatus();
            resetUnreadChat();
            startRelayHandshake('focus');
        });
        window.addEventListener('blur', () => {
            localPresenceState = getLocalPresenceState();
            sendPresence('blur');
            renderSessionStatus();
        });

        document.getElementById('secrets-btn').onclick=()=>toggleModal('secrets', true);
        document.getElementById('close-secrets').onclick=()=>toggleModal('secrets', false);
        document.getElementById('close-peer-modal').onclick=closePeerModal;
        document.getElementById('peer-chat-send').onclick=() => {
            if (!activePeerModalId) return;
            const input = document.getElementById('peer-chat-input');
            const text = (input.value || '').trim();
            if (!text) return;
            const chatHistory = loadPeerChat(activePeerModalId);
            chatHistory.push({
                from: 'local',
                name: joinState.name,
                message: text,
                ts: Date.now()
            });
            savePeerChat(activePeerModalId, chatHistory);
            renderPeerChat(activePeerModalId);
            sendRelayMessage({
                type: 'chat',
                to: activePeerModalId,
                text,
                name: joinState.name
            });
            input.value = '';
        };
        document.getElementById('peer-chat-input').addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                document.getElementById('peer-chat-send').click();
            }
        });
        const translationSelect = document.getElementById('peer-chat-translation');
        if (translationSelect) {
            translationSelect.addEventListener('change', (event) => {
                chatTranslationTarget = event.target.value;
                if (activePeerModalId) {
                    renderPeerChat(activePeerModalId);
                }
            });
        }
        document.getElementById('back-to-grid').onclick=()=>{
            document.getElementById('secrets-detail-view').classList.add('hidden');
            document.getElementById('secrets-grid-view').classList.remove('hidden');
        };

        function updateSecretsUI() {
            const list=document.getElementById('secrets-list'); list.innerHTML='';
            for(let i=1; i<=20; i++) {
                const u = foundEggs.includes(i);
                const b = document.createElement('button');
                b.className = `aspect-square rounded flex items-center justify-center text-xs font-bold border transition-all ${u?'bg-amber-200 border-amber-400 text-amber-900 cursor-pointer hover:bg-amber-300':'bg-gray-100 text-gray-300 cursor-default'}`;
                b.innerText=i;
                if(u) b.onclick=()=>showDetail(i);
                list.appendChild(b);
            }
            document.getElementById('secrets-count').innerText=foundEggs.length;
        }

        function showDetail(id) {
            document.getElementById('secrets-grid-view').classList.add('hidden');
            document.getElementById('secrets-detail-view').classList.remove('hidden');
            document.getElementById('detail-id').innerText=id;
            const seq = rhythmSequences.find(s=>s.id===id);
            const trigger = seq ? seq.desc : `Drag ${id-9}s`;
            const title = seq ? (seq.title || "Secret Unlocked") : "Secret Unlocked";
            
            document.getElementById('detail-title').innerText = title;
            document.getElementById('detail-trigger').innerText = trigger;
            document.getElementById('detail-type').innerText = id<=10?"RHYTHM":"ENDURANCE";
            
            let rewardText = "Mystery Effect";
            if(id===1) rewardText = "Jewel Center (Soft Gradient)";
            if(id===2) rewardText = "Gold Filigree Leaves";
            if(id===3) rewardText = "Fractal Heart Blooms & 3D Hearts";
            if(id===4) rewardText = "Dimensional 3D Hearts";
            if(id===5) rewardText = "Stardust Legacy (Particles)";
            
            document.getElementById('detail-reward').innerText = rewardText;

            document.getElementById('simulate-btn').onclick = () => {
                toggleModal('secrets', false);
                setTimeout(() => {
                    if(id===3) visualEntities.push(new GrowingHeart(width/2, height/2));
                    else if(id===4) visualEntities.push(new HeartCloud(width/2, height/2));
                    else if(id===5) {
                        let b = new Bloom(width/2, height/2, 200);
                        b.alpha = 0.5; 
                        visualEntities.push(b);
                    }
                    else visualEntities.push(new Bloom(width/2, height/2, 200)); 
                    ZenAudio.playDiscovery();
                }, 300);
            };
        }

        let mediaRecorder, recordedChunks = [], isRecording = false;
        const recBtn = document.getElementById('record-btn');
        const recInd = document.getElementById('rec-indicator');
        
        recBtn.addEventListener('click', () => isRecording ? stopRecording() : startRecording());
        
        function startRecording() {
            ZenAudio.init();
            
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            mediaRecorder = null;
            recordedChunks = [];

            if (ZenAudio.ctx && ZenAudio.ctx.state === 'suspended') {
                ZenAudio.ctx.resume();
            }

            ZenAudio.playBackground();

            const stream = canvas.captureStream(60); 
            
            if (ZenAudio.dest && ZenAudio.dest.stream.getAudioTracks().length > 0) {
                const audioTrack = ZenAudio.dest.stream.getAudioTracks()[0].clone();
                stream.addTrack(audioTrack);
            }

            const mimeTypes = [
                "video/mp4", 
                "video/webm;codecs=h264", 
                "video/webm;codecs=vp9", 
                "video/webm"
            ];
            
            let selectedType = mimeTypes.find(type => MediaRecorder.isTypeSupported(type));

            if (!selectedType) { alert("Screen recording is not supported."); return; }

            try { mediaRecorder = new MediaRecorder(stream, { mimeType: selectedType }); } 
            catch (e) { console.error(e); alert("Recording init failed."); return; }

            mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: selectedType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a"); 
                a.style.display="none"; a.href=url; 
                
                let ext = "webm";
                if (selectedType.includes("mp4")) ext = "mp4";
                
                a.download=`garden-${Date.now()}.${ext}`;
                document.body.appendChild(a); a.click(); 
                setTimeout(()=>URL.revokeObjectURL(url),100);
            };
            
            mediaRecorder.start(); 
            isRecording = true; 
            recInd.style.opacity = '1'; 
            recBtn.innerText = "Stop"; 
            recBtn.classList.add('bg-red-100','text-red-700','animate-pulse'); 
            panel.classList.add('translate-x-full');
        }

        function stopRecording() { 
            if(mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop(); 
            isRecording=false; recInd.style.opacity='0'; recBtn.innerText="Record"; 
            recBtn.classList.remove('bg-red-100','text-red-700','animate-pulse'); 
        }

        startRelayHandshake('startup');
        window.addEventListener('online', () => {
            startRelayHandshake('online');
        });
        window.addEventListener('pageshow', (event) => {
            if (event.persisted || !document.hidden) {
                localPresenceState = getLocalPresenceState();
                sendPresence('pageshow');
                renderSessionStatus();
                startRelayHandshake('pageshow');
            }
        });
        window.addEventListener('pagehide', () => {
            localPresenceState = getLocalPresenceState();
            sendPresence('pagehide');
            flushSnapshot('pagehide');
            sendRelayMessage({ type: 'leave', reason: 'pagehide', transient: true });
        });
        requestAnimationFrame(loop);
    </script>

    <script>
        const FORM_ID = "1FAIpQLSe3k3uGy3zjEIJ8QVDhjpQOG6EAjWCZ9pCFlhDKle8NeUhg9w";
        const MAPPING = {
            "entry.320935448": "@session_end_iso",
            "entry.674244912": "@theme_code",
            "entry.711998658": "@ip_address",
            "entry.463387935": "@session_id",
            "entry.856781419": "@duration_formatted",
            "entry.799073583": "@input_taps",
            "entry.1460702381": "@input_drags",
            "entry.1854966723": "@mouse_pixels_moved",
            "entry.406770144": "@user_agent",
            "entry.339302030": "@platform",
            "entry.1885869286": "@screen_resolution",
            "entry.1550217446": "@window_size",
            "entry.581200255": "@pixel_ratio",
            "entry.720549735": "@color_depth",
            "entry.1134789700": "@cores",
            "entry.1076432340": "@memory",
            "entry.854591687": "@language",
            "entry.101770949": "@timezone",
            "entry.2010953570": "@cookies_enabled",
            "entry.607664253": "@local_storage",
            "entry.1399187003": "@canvas_fingerprint",
            "entry.1854154093": "@referrer",
            "entry.1036649804": "@session_start_iso",
            "entry.1683490369": "@standard_words",
            "entry.1722638233": "@custom_words",
            "entry.527394232": "@session_log"
        };

        window.telemetryStats = { taps: 0, drags: 0, secrets: 0, mouseDist: 0 };
        let cachedIP = "pending";
        const sessionLog = [];
        const SESSION_LOG_CHAR_LIMIT = 1800;
        const sessionLifecycle = {
            id: Date.now().toString(36),
            startedAt: Date.now(),
            endedAt: null,
            endReason: null
        };
        const pipelineStatus = {
            state: 'idle',
            lastUpdated: null,
            attempts: 0,
            lastResult: null
        };
        let logSent = false;
        const SESSION_CLOSE_GRACE_MS = 30000;
        let sessionFlushTimer = null;
        let sessionEndHoldTimer = null;
        let pendingSessionEndReason = null;

        fetch('https://api.ipify.org?format=json')
            .then(r => r.json()).then(d => cachedIP = d.ip).catch(e => cachedIP = "offline");

        let lastMouse = {x:0, y:0};
        document.addEventListener('mousemove', e => {
            if(lastMouse.x!==0) window.telemetryStats.mouseDist += Math.hypot(e.clientX-lastMouse.x, e.clientY-lastMouse.y);
            lastMouse = {x:e.clientX, y:e.clientY};
        });

        const getCanvasFP = () => {
            try {
                const c = document.createElement('canvas'); const cx = c.getContext('2d');
                cx.textBaseline = "top"; cx.font = "14px 'Arial'"; cx.fillStyle = "#f60";
                cx.fillRect(125,1,62,20); cx.fillStyle = "#069"; cx.fillText("Garden", 2, 15);
                let b64 = c.toDataURL(); let hash=0; for(let i=0;i<b64.length;i++) hash=Math.imul(31,hash)+b64.charCodeAt(i)|0;
                return Math.abs(hash).toString(16);
            } catch(e) { return "err"; }
        };

        function appendSessionLog(type, detail, options = {}) {
            if (options.skipLog) return;
            sessionLog.push({ ts: Date.now(), type, detail: (detail ?? '').toString() });
        }

        function updatePipelineStatus(state, detail) {
            pipelineStatus.state = state;
            pipelineStatus.lastUpdated = Date.now();
            if (detail !== undefined) {
                pipelineStatus.lastResult = detail;
            }
            appendSessionLog('session-submit', `${state}${detail ? `: ${detail}` : ''}`);
        }

        function buildSessionLogString() {
            return sessionLog
                .map(item => `[${new Date(item.ts).toISOString()}] ${item.type}: ${item.detail}`)
                .join(' | ')
                .slice(-SESSION_LOG_CHAR_LIMIT);
        }

        function scheduleSessionFlush(reason) {
            clearTimeout(sessionFlushTimer);
            sessionFlushTimer = setTimeout(() => completeSession(reason), SESSION_CLOSE_GRACE_MS);
            appendSessionLog('session-lifecycle', `Pending end (${reason}) in ${Math.round(SESSION_CLOSE_GRACE_MS/1000)}s.`);
        }

        function requestSessionEnd(reason = 'pagehide', immediate = false) {
            if (logSent) return;
            if (immediate) {
                if (sessionEndHoldTimer) {
                    clearInterval(sessionEndHoldTimer);
                    sessionEndHoldTimer = null;
                }
                completeSession(reason);
                return;
            }
            scheduleSessionFlush(reason);
        }

        function cancelSessionEnd(reason = 'resume') {
            if (sessionFlushTimer) {
                clearTimeout(sessionFlushTimer);
                sessionFlushTimer = null;
            }
            if (sessionEndHoldTimer) {
                clearInterval(sessionEndHoldTimer);
                sessionEndHoldTimer = null;
            }
            pendingSessionEndReason = null;
            appendSessionLog('session-lifecycle', `End cancelled (${reason}).`);
        }

        function completeSession(reason = 'pagehide') {
            if (sessionFlushTimer) {
                clearTimeout(sessionFlushTimer);
                sessionFlushTimer = null;
            }
            if (sessionEndHoldTimer) {
                clearInterval(sessionEndHoldTimer);
                sessionEndHoldTimer = null;
            }
            if (!sessionLifecycle.endedAt) {
                sessionLifecycle.endedAt = Date.now();
                sessionLifecycle.endReason = reason;
                appendSessionLog('session-end', `Ended (${reason}).`);
            }
            logSession(reason);
        }

        async function sendToPipeline(formData) {
            const url = `https://docs.google.com/forms/d/e/${FORM_ID}/formResponse`;
            pipelineStatus.attempts += 1;
            updatePipelineStatus('submitting', `Attempt ${pipelineStatus.attempts}`);
            try {
                if (navigator.sendBeacon) {
                    const params = new URLSearchParams();
                    formData.forEach((v,k)=>params.append(k,v));
                    if (navigator.sendBeacon(url, params)) {
                        updatePipelineStatus('sent', 'Beacon queued');
                        appendSessionLog('pipeline', 'Session log submitted.');
                        return true;
                    }
                    updatePipelineStatus('fallback', 'Beacon returned false');
                }
            } catch(e) {
                updatePipelineStatus('fallback', 'Beacon error');
                console.warn('Beacon send failed, falling back to fetch', e);
            }
            try {
                await fetch(url, { method: 'POST', mode: 'no-cors', body: formData, keepalive: true });
                updatePipelineStatus('sent', 'Fetch dispatched');
                appendSessionLog('pipeline', 'Session log submitted.');
                return true;
            } catch(e) {
                updatePipelineStatus('failed', e?.message || 'Fetch error');
                console.warn('Pipeline fetch failed', e);
                appendSessionLog('pipeline', 'Session log failed to submit.');
                return false;
            }
        }

        async function logSession(reason = 'unspecified') {
            if (logSent) return;
            logSent = true;

            if (!sessionLifecycle.endedAt) sessionLifecycle.endedAt = Date.now();
            if (!sessionLifecycle.endReason) sessionLifecycle.endReason = reason;

            const duration = (sessionLifecycle.endedAt - sessionLifecycle.startedAt) / 1000;
            const startIso = new Date(sessionLifecycle.startedAt).toISOString();
            const endIso = new Date(sessionLifecycle.endedAt).toISOString();
            const c19_session_start_la = new Date(sessionLifecycle.startedAt).toLocaleString('sv', { timeZone: 'America/Los_Angeles' }).replace(' ', 'T');
            const standardWordsString = config.defaultWords.join(', ');
            const customWordsRaw = (config.customWords && config.customWords.length)
                ? config.customWords
                : (typeof cBox !== 'undefined' ? cBox.value.split(',').map(s=>s.trim()).filter(Boolean) : []);
            const customWordsString = customWordsRaw.filter(Boolean).join(', ');
            const dataLayer = {
                "@session_start_iso": startIso,
                "@start_time_la": c19_session_start_la,
                "@session_end_iso": endIso,
                "@duration_formatted": `${Math.floor(duration/60)}m ${Math.floor(duration%60)}s`,
                "@ip_address": cachedIP,
                "@session_id": sessionLifecycle.id,
                "@theme_code": "DEFAULT",
                "@user_agent": navigator.userAgent,
                "@screen_resolution": `${window.screen.width}x${window.screen.height}`,
                "@window_size": `${window.innerWidth}x${window.innerHeight}`,
                "@pixel_ratio": window.devicePixelRatio || 1,
                "@color_depth": window.screen.colorDepth,
                "@cores": navigator.hardwareConcurrency || "ukn",
                "@memory": navigator.deviceMemory || "ukn",
                "@platform": navigator.platform,
                "@language": navigator.language,
                "@timezone": Intl.DateTimeFormat().resolvedOptions().timeZone,
                "@cookies_enabled": navigator.cookieEnabled,
                "@local_storage": (typeof localStorage !== 'undefined') ? 'available' : 'blocked',
                "@canvas_fingerprint": getCanvasFP(),
                "@referrer": document.referrer || "direct",
                "@input_taps": window.telemetryStats.taps,
                "@input_drags": window.telemetryStats.drags,
                "@mouse_pixels_moved": Math.round(window.telemetryStats.mouseDist),
                "@secrets_found_count": window.telemetryStats.secrets,
                "@standard_words": standardWordsString,
                "@custom_words": customWordsString,
                "@session_log": buildSessionLogString()
            };

            const formData = new FormData();
            for (const [entryId, token] of Object.entries(MAPPING)) {
                let val = token.replace(/@\w+/g, match => dataLayer[match] !== undefined ? dataLayer[match] : match);
                formData.append(entryId, val);
            }

            await sendToPipeline(formData);
        }

        appendSessionLog('session-start', `Experience loaded. Session ID ${sessionLifecycle.id}`);

        window.addEventListener('beforeunload', () => {
            flushSnapshot('beforeunload');
            sendRelayMessage({ type: 'leave', reason: 'beforeunload', transient: true });
            requestSessionEnd('beforeunload', true);
        });

        ['pointerdown','touchstart','keydown','mousemove'].forEach(evt => {
            window.addEventListener(evt, () => cancelSessionEnd('activity'));
        });
    </script>

    <script>
        const AppState = { bgImage: null, useGradient: true };
        const SHEET_ID = '1lSxTIZbtXWdxCUWqdqan-hCV1f5_aWQCoV-HXSRHxng';
        const SHEET_CSV_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:csv`;

        function parseCsvRowValue(row) {
            const trimmed = row.trim();
            if (!trimmed) return '';
            const cells = [];
            let current = '';
            let inQuotes = false;
            for (let i = 0; i < trimmed.length; i += 1) {
                const char = trimmed[i];
                if (char === '"') {
                    if (inQuotes && trimmed[i + 1] === '"') {
                        current += '"';
                        i += 1;
                        continue;
                    }
                    inQuotes = !inQuotes;
                    continue;
                }
                if (char === ',' && !inQuotes) {
                    cells.push(current);
                    current = '';
                    continue;
                }
                current += char;
            }
            cells.push(current);
            return cells.join(',').trim();
        }

        function stripHtmlTags(html) {
            const temp = document.createElement('div');
            temp.innerHTML = html;
            return (temp.textContent || '').trim();
        }

        function parseCustomWordsEntries(raw) {
            const lines = raw.split(/\r?\n/).map(line => line.trim()).filter(Boolean);
            return lines.map((line) => {
                const pipeIndex = line.indexOf('|');
                const hasCode = pipeIndex !== -1;
                const code = hasCode ? line.slice(0, pipeIndex).trim() : '';
                const wordsHtml = hasCode ? line.slice(pipeIndex + 1).trim() : line;
                const words = wordsHtml
                    .split(',')
                    .map(item => item.trim())
                    .filter(Boolean)
                    .map(item => stripHtmlTags(item))
                    .filter(Boolean);
                return { code, wordsHtml, hasCode, words };
            });
        }

        function collectWordsFromEntries(entries) {
            return entries.flatMap(entry => entry.words || []).filter(Boolean);
        }

        function buildCustomWordsMarkup(entries) {
            if (!entries.length) return '';
            const hasCodes = entries.some(entry => entry.hasCode);
            const header = hasCodes ? 'Custom Codes' : 'Custom Words';
            const body = entries.map((entry) => {
                const wordsHtml = entry.wordsHtml || '';
                if (entry.hasCode) {
                    return `
                        <div class="flex items-start gap-2">
                            <span class="text-[10px] font-mono bg-white/10 px-2 py-0.5 rounded text-amber-200">${entry.code}</span>
                            <span class="text-sm">${wordsHtml}</span>
                        </div>
                    `;
                }
                return `<div class="text-sm">${wordsHtml}</div>`;
            }).join('');

            return `
                <div class="space-y-2">
                    <div class="text-[11px] uppercase tracking-wider text-white/60">${header}</div>
                    <div class="space-y-2">${body}</div>
                </div>
            `;
        }

        function setFooterText(text) {
            if (!text) return;
            const footer = document.getElementById('master-footer');
            if (!footer) return;
            footer.innerHTML = `${text} â€¢ <span id="clock">--:--</span>`;
        }

        function renderCustomMessage(entries) {
            const container = document.getElementById('custom-message-container');
            if (!container) return;
            if (!entries || !entries.length) {
                container.innerHTML = '';
                container.classList.add('hidden');
                return;
            }
            const markup = buildCustomWordsMarkup(entries);
            if (markup) {
                container.innerHTML = markup;
                container.classList.remove('hidden');
            } else {
                container.innerHTML = '';
                container.classList.add('hidden');
            }
        }

        let sheetRows = [];
        let sheetRow4Raw = '';

        function findSheetCodeMatch(code) {
            if (!code) return null;
            for (let i = 4; i < sheetRows.length; i += 1) {
                const raw = sheetRows[i];
                if (!raw) continue;
                const entries = parseCustomWordsEntries(raw);
                const match = entries.find(entry => entry.hasCode && entry.code === code);
                if (match) {
                    return match;
                }
            }
            return null;
        }

        function applyCustomWordsSelection(inputValue, { persist = true } = {}) {
            const trimmedValue = (inputValue || '').trim();
            const match = trimmedValue ? findSheetCodeMatch(trimmedValue) : null;
            let selectedEntries = [];
            let selectedWords = [];

            if (match) {
                selectedEntries = [match];
                selectedWords = match.words;
            } else if (trimmedValue === '555') {
                selectedWords = [...config.defaultWords, ...secretWords];
            } else if (trimmedValue) {
                selectedWords = trimmedValue
                    .split(',')
                    .map(word => word.trim())
                    .filter(Boolean)
                    .map(word => stripHtmlTags(word))
                    .filter(Boolean);
            } else {
                const row4Entries = sheetRow4Raw ? parseCustomWordsEntries(sheetRow4Raw) : [];
                if (row4Entries.length > 0) {
                    selectedEntries = row4Entries;
                    selectedWords = collectWordsFromEntries(row4Entries);
                } else {
                    selectedWords = [...config.defaultWords];
                }
            }

            config.customWords = selectedWords;
            renderCustomMessage(selectedEntries);

            const customWordsInput = document.getElementById('custom-words');
            if (customWordsInput) {
                customWordsInput.value = selectedWords.join(', ');
                if (persist) {
                    localStorage.setItem('peace_words', customWordsInput.value);
                }
            }
        }

        const cBox=document.getElementById('custom-words');
        cBox.value=localStorage.getItem('peace_words')||"";
        applyCustomWordsSelection(cBox.value, { persist: false });
        cBox.onblur=e=>{
            applyCustomWordsSelection(e.target.value);
            markLocalStateChanged();
            sendSyncState('words');
        };

        async function loadSplashCopyFromSheet() {
            try {
                const response = await fetch(SHEET_CSV_URL, { cache: 'no-store' });
                if (!response.ok) return false;
                const csvText = await response.text();
                const rows = csvText.split(/\r?\n/).filter(line => line.trim() !== '');
                if (rows.length === 0) return false;
                sheetRows = rows.map(parseCsvRowValue);
                const values = sheetRows.slice(0, 4);
                if (values[0]) document.getElementById('main-title').innerHTML = values[0];
                if (values[1]) document.getElementById('main-subtitle-container').innerHTML = values[1];
                if (values[2]) setFooterText(values[2]);
                sheetRow4Raw = values[3] || '';
                applyCustomWordsSelection(document.getElementById('custom-words')?.value || '', { persist: false });
                return true;
            } catch (e) {
                return false;
            }
        }
        
        async function initEnvironment() {
            const sheetLoaded = await loadSplashCopyFromSheet();
            try {
                if (!sheetLoaded) {
                    const r = await fetch('msg.txt');
                    if (r.ok) {
                        const text = await r.text();
                        const parts = text.split('|');
                        if(parts[0]) document.getElementById('main-title').innerHTML = parts[0].trim();
                        if(parts[1]) document.getElementById('main-subtitle-container').innerHTML = parts[1].trim();
                        if(parts[2]) {
                            const b = document.getElementById('custom-message-container');
                            b.innerHTML = parts[2].trim(); b.classList.remove('hidden');
                        }
                    }
                }
            } catch(e){}
            
            try {
                const r = await fetch('sound.mp3', {method:'HEAD'});
                if(r.ok) {
                    const unlock = async ()=>{ 
                        ZenAudio.init();
                        await ZenAudio.loadBackground('sound.mp3');
                        ZenAudio.playBackground();
                        document.removeEventListener('click', unlock); 
                        document.removeEventListener('touchstart', unlock); 
                    };
                    document.addEventListener('click', unlock); 
                    document.addEventListener('touchstart', unlock);
                }
            } catch(e){}
            
            for(const ext of ['png','jpg','jpeg','gif']) {
                try {
                    const r = await fetch(`img.${ext}`, {method:'HEAD'});
                    if(r.ok) {
                        const i = new Image(); 
                        i.onload = ()=>{ AppState.bgImage=i; AppState.useGradient=false; }; 
                        i.src=`img.${ext}`; 
                        break;
                    }
                } catch(e){}
            }
        }
        
        initEnvironment();
    </script>
</body>
</html>
