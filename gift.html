<!-- A Gift for You - v13.1 - 2025-12-12 10:00 PM -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport">
    <title>A Gift for You</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,1,0" rel="stylesheet">
    <style>
        body {
            touch-action: none;
            overscroll-behavior: none;
            -webkit-tap-highlight-color: transparent;
            background-color: #000;
        }
        /* Hide scrollbar for settings panel */
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        
        /* Slider Styling */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px; width: 16px;
            border-radius: 50%; background: #8ec5fc;
            cursor: pointer; margin-top: -6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer;
            background: #e2e8f0; border-radius: 2px;
        }
        
        /* Modal Animation Classes */
        .modal { transition: opacity 0.3s ease, visibility 0.3s ease; }
        .modal.invisible { opacity: 0; visibility: hidden; pointer-events: none; }
        .modal.visible { opacity: 1; visibility: visible; pointer-events: auto; }
        
        .modal-content { transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
        .scale-in { transform: scale(1); }
        .scale-out { transform: scale(0.95); }

        /* Code Block Styling */
        pre { white-space: pre-wrap; word-wrap: break-word; }
        
        /* Added for v13 Text Injection support */
        #custom-message-container { pointer-events: auto; }
        #custom-message-container a { color: #8ec5fc; text-decoration: underline; }
    </style>
</head>
<body class="overflow-hidden h-screen w-screen font-sans text-slate-800">

    <canvas class="block absolute top-0 left-0 w-full h-full z-0" id="gameCanvas"></canvas>

    <div class="absolute inset-0 flex flex-col items-center justify-center pointer-events-none z-10 transition-opacity duration-1000 opacity-100 text-white/90 text-center drop-shadow-md" id="overlay">
        <h1 class="text-3xl md:text-5xl font-light mb-4 tracking-widest" id="main-title">A Gift for You</h1>
        <div id="main-subtitle-container">
            <p class="text-lg md:text-xl font-light leading-relaxed">
                Tap to Bloom<br>
                Double Tap for Hearts<br>
                <span class="text-sm opacity-70 mt-2 block">Drag to Strum</span>
            </p>
        </div>
        <div id="custom-message-container" class="mt-4 hidden bg-black/30 p-4 rounded-lg backdrop-blur-sm max-w-lg text-sm text-left"></div>
    </div>

    <div class="fixed top-5 left-5 flex items-center gap-2 bg-black/40 backdrop-blur px-3 py-2 rounded-full text-white text-xs font-bold tracking-wide opacity-0 transition-opacity z-50 pointer-events-none" id="rec-indicator">
        <div class="w-2.5 h-2.5 bg-red-500 rounded-full animate-pulse"></div>
        REC
    </div>

    <div class="fixed bottom-3 inset-x-0 text-center text-[10px] text-white/60 pointer-events-none z-10 tracking-wider" id="master-footer">
      â€¢ A Gift for You â€¢ Penang 2026 â€¢ <span id="clock">--:--</span>
    </div>

    <button class="fixed top-5 right-5 w-12 h-12 bg-white/20 backdrop-blur-md rounded-full flex items-center justify-center text-white hover:bg-white/30 active:scale-95 transition-all shadow-lg z-50" id="settings-trigger">
        <span class="material-symbols-outlined">settings</span>
    </button>

    <aside class="fixed top-0 right-0 w-80 h-full bg-white/95 backdrop-blur-xl shadow-2xl transform transition-transform duration-300 translate-x-full z-50 flex flex-col no-scrollbar overflow-y-auto" id="settings-panel">
        
        <div class="p-6 flex justify-between items-center border-b border-gray-100">
            <h2 class="text-lg font-bold text-gray-700 tracking-wide uppercase">Settings</h2>
            <button class="text-gray-400 hover:text-gray-700 transition-colors" id="close-btn">
                <span class="material-symbols-outlined text-3xl">close</span>
            </button>
        </div>

        <div class="p-6 space-y-8 flex-1">
            
            <div class="flex justify-between items-center">
                <span class="text-xs font-bold text-gray-500 uppercase tracking-wider">Sound</span>
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="audio-toggle" class="sr-only peer" checked>
                    <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-300"></div>
                </label>
            </div>

            <div class="space-y-3">
                <span class="text-xs font-bold text-gray-500 uppercase tracking-wider block">Background</span>
                <div class="space-y-2">
                    <input class="block w-full text-xs text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-xs file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100" id="bg-upload-input" type="file" accept="image/*">
                    <div class="grid grid-cols-2 gap-2">
                        <button class="w-full py-2 bg-blue-100 text-blue-700 text-xs font-semibold rounded hover:bg-blue-200 transition" id="apply-bg-btn">
                            Apply Image
                        </button>
                        <button class="w-full py-2 bg-gray-100 text-gray-500 text-xs font-medium rounded hover:bg-gray-200 transition" id="reset-bg-btn">
                            Reset Gradient
                        </button>
                    </div>
                </div>
            </div>

            <div class="space-y-2">
                <span class="text-xs font-bold text-gray-500 uppercase tracking-wider block">Custom Words</span>
                <textarea class="w-full p-3 text-sm text-gray-700 bg-gray-50 border border-gray-200 rounded-lg focus:ring-blue-300 focus:border-blue-300 resize-none h-24" id="custom-words" placeholder="e.g. You, Peace, Kindness..."></textarea>
            </div>

            <div class="space-y-2">
                <div class="flex items-center justify-between">
                    <span class="text-xs font-bold text-gray-500 uppercase tracking-wider block">Live Sync (Peer to Peer)</span>
                    <span id="p2p-status" class="text-[10px] px-2 py-1 rounded-full bg-slate-200 text-slate-600">Connectingâ€¦</span>
                </div>
                <div class="space-y-1">
                    <label class="text-[11px] text-gray-600 font-semibold uppercase tracking-wide flex items-center justify-between">
                        Session
                        <span class="text-[10px] text-gray-400 font-normal">WebRTC signaling</span>
                    </label>
                    <div class="flex gap-2">
                        <input id="p2p-session" class="flex-1 border border-slate-200 rounded-lg px-3 py-2 text-sm bg-white focus:ring-2 focus:ring-blue-200" readonly>
                        <button id="p2p-new-session" class="px-3 py-2 text-[11px] bg-slate-50 text-slate-700 rounded border border-slate-200 hover:bg-slate-100 transition">New</button>
                    </div>
                </div>
                <div class="flex items-center gap-2 text-[11px] text-slate-600 bg-slate-50 border border-slate-200 rounded-lg px-3 py-2">
                    <div class="flex-1">
                        <p class="font-semibold text-slate-700">Shareable Link</p>
                        <p id="p2p-share-url" class="truncate text-slate-500">Generatingâ€¦</p>
                    </div>
                    <button id="p2p-copy-url" class="px-2 py-1 text-[10px] bg-blue-50 text-blue-700 rounded border border-blue-200 hover:bg-blue-100 transition">Copy</button>
                </div>
                <div class="mt-2 p-3 bg-slate-50 border border-slate-200 rounded-lg text-[11px] text-slate-600 space-y-2">
                    <div class="flex items-center justify-between">
                        <p class="font-semibold text-slate-700 text-xs">Session Log</p>
                        <span id="pipeline-status" class="text-[10px] px-2 py-1 rounded-full bg-slate-200 text-slate-600">Idle</span>
                    </div>
                    <div id="session-log-feed" class="max-h-28 overflow-y-auto space-y-1 text-[10px] leading-snug">
                        <p class="text-slate-400">No activity yet.</p>
                    </div>
                </div>
                <p class="text-[11px] text-gray-500 leading-snug">Share the link. Peers mirror background, audio, words, taps, and drags in real time. No master/guest.</p>
            </div>

            <div class="space-y-6">
                <div class="space-y-2">
                    <div class="flex justify-between">
                        <span class="text-xs font-bold text-gray-500 uppercase tracking-wider">Fade Duration (Flowers)</span>
                    </div>
                    <input type="range" id="decay-slider" min="0" max="5" step="1" value="2" class="w-full bg-gray-200 rounded-lg appearance-none cursor-pointer">
                </div>

                <div class="space-y-2">
                    <div class="flex justify-between">
                        <span class="text-xs font-bold text-gray-500 uppercase tracking-wider">Trail Duration & Speed</span>
                    </div>
                    <input type="range" id="trail-slider" min="1" max="10" step="1" value="5" class="w-full bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    <div class="flex justify-between text-[10px] text-gray-400 mt-1">
                        <span>Short/Fast</span>
                        <span>Long/Slow</span>
                    </div>
                </div>

                <div class="space-y-2">
                    <div class="flex justify-between">
                        <span class="text-xs font-bold text-gray-500 uppercase tracking-wider">Growth Speed</span>
                    </div>
                    <input type="range" id="speed-slider" min="1" max="100" value="50" class="w-full bg-gray-200 rounded-lg appearance-none cursor-pointer">
                </div>
            </div>

            <div class="grid grid-cols-2 gap-3 pt-4 border-t border-gray-100">
                <button class="col-span-1 px-4 py-3 bg-orange-50 text-orange-700 text-sm font-semibold rounded-xl hover:bg-orange-100 transition text-center" id="record-btn">Record</button>
                <button class="col-span-1 px-4 py-3 bg-green-50 text-green-700 text-sm font-semibold rounded-xl hover:bg-green-100 transition text-center" id="save-btn">Snapshot</button>
                <button class="col-span-1 px-4 py-3 bg-gray-50 text-gray-700 text-sm font-medium rounded-xl hover:bg-gray-100 transition text-center" id="theme-btn">Theme</button>
                <button class="col-span-1 px-4 py-3 bg-indigo-50 text-indigo-700 text-sm font-semibold rounded-xl hover:bg-indigo-100 transition text-center" id="autoplay-btn">Auto-Play</button>
                <button class="col-span-1 px-4 py-3 bg-red-50 text-red-700 text-sm font-medium rounded-xl hover:bg-red-100 transition text-center" id="clear-btn">Clear</button>
                
                <button class="col-span-2 mt-2 py-4 bg-amber-50 text-amber-700 font-bold rounded-xl hover:bg-amber-100 transition text-center flex items-center justify-center gap-2 border border-amber-200 shadow-sm" id="secrets-btn">
                    <span class="material-symbols-outlined">key</span> Open Secrets
                </button>

                 <button class="col-span-1 mt-2 py-3 bg-blue-50 text-blue-700 text-sm font-bold rounded-xl hover:bg-blue-100 transition text-center flex items-center justify-center gap-2 border border-blue-200" id="info-btn">
                    <span class="material-symbols-outlined text-sm">code</span> Code
                </button>
                <button class="col-span-1 mt-2 py-3 bg-purple-50 text-purple-700 text-sm font-bold rounded-xl hover:bg-purple-100 transition text-center flex items-center justify-center gap-2 border border-purple-200" id="req-btn">
                    <span class="material-symbols-outlined text-sm">list</span> Reqs
                </button>
            </div>
        </div>
    </aside>

    <div id="secrets-modal" class="fixed inset-0 bg-black/60 backdrop-blur-sm z-[100] flex items-center justify-center invisible modal">
        <div id="secrets-content" class="bg-white rounded-2xl shadow-2xl w-11/12 max-w-md p-6 transform scale-out modal-content">
            <div class="flex justify-between items-center mb-4 border-b pb-2">
                <h3 class="text-xl font-bold text-gray-800 flex items-center gap-2">
                    <span class="material-symbols-outlined text-amber-500">auto_awesome</span> 
                    Discoveries
                </h3>
                <button id="close-secrets" class="text-gray-400 hover:text-gray-800 p-2 hover:bg-gray-100 rounded-full transition-colors">
                    <span class="material-symbols-outlined">close</span>
                </button>
            </div>

            <div id="secrets-grid-view">
                <p class="text-sm text-gray-500 mb-4">
                    Unlock patterns by experimenting with rhythms (Taps) and flow (Drags). Click a discovery to see its activation code.
                </p>
                <div id="secrets-list" class="grid grid-cols-5 gap-2 max-h-60 overflow-y-auto p-1">
                    </div>
                <div class="text-center text-xs text-gray-400 mt-4">
                    Found: <span id="secrets-count">0</span> / 20
                </div>
            </div>

            <div id="secrets-detail-view" class="hidden flex flex-col">
                <button id="back-to-grid" class="text-xs text-blue-500 mb-2 flex items-center hover:underline self-start">
                    <span class="material-symbols-outlined text-sm mr-1">arrow_back</span> Back
                </button>
                
                <div class="bg-amber-50 rounded-xl p-5 border border-amber-100 text-center space-y-4">
                    <div id="detail-id" class="w-16 h-16 bg-amber-200 rounded-full flex items-center justify-center mx-auto text-amber-800 font-bold text-2xl shadow-inner">?</div>
                    
                    <div>
                        <h4 id="detail-title" class="text-lg font-bold text-amber-900">Secret Unlocked</h4>
                        <p id="detail-type" class="text-xs text-amber-700/70 uppercase tracking-wide font-bold mt-1">RHYTHM</p>
                    </div>

                    <div class="text-left bg-white/60 p-4 rounded-lg text-sm border border-amber-100 shadow-sm">
                        <p class="mb-2"><span class="font-bold text-gray-600 block text-xs uppercase mb-1">Trigger:</span>
                        <span id="detail-trigger" class="font-mono text-lg text-amber-600 tracking-wider bg-amber-50 px-2 py-1 rounded">Tap Tap</span></p>
                        
                        <p><span class="font-bold text-gray-600 block text-xs uppercase mb-1">Visual Effect:</span>
                        <span id="detail-reward" class="italic text-gray-700">Blooming Mandala</span></p>
                    </div>

                    <button id="simulate-btn" class="w-full py-3 bg-gradient-to-r from-amber-400 to-amber-500 text-white rounded-xl font-bold shadow-lg hover:from-amber-500 hover:to-amber-600 active:scale-95 transition flex items-center justify-center gap-2">
                        <span class="material-symbols-outlined">play_circle</span> Play Example
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div id="code-modal" class="fixed inset-0 bg-black/60 backdrop-blur-sm z-[100] flex items-center justify-center invisible modal">
        <div class="bg-white rounded-2xl shadow-2xl w-11/12 max-w-4xl h-[80vh] p-6 transform scale-out modal-content flex flex-col">
            <div class="flex justify-between items-center mb-4 border-b pb-2 shrink-0">
                <h3 class="text-xl font-bold text-gray-800 flex items-center gap-2">
                    <span class="material-symbols-outlined text-blue-500">code</span> Source Code
                </h3>
                <button id="close-code" class="text-gray-400 hover:text-gray-800 p-2 hover:bg-gray-100 rounded-full transition-colors">
                    <span class="material-symbols-outlined">close</span>
                </button>
            </div>
            <div class="flex-1 overflow-auto bg-gray-50 p-4 rounded border border-gray-200 font-mono text-xs">
                <pre id="source-code-display">Loading...</pre>
            </div>
            <div class="mt-4 flex justify-end shrink-0">
                <button id="copy-code-btn" class="px-4 py-2 bg-blue-600 text-white rounded font-bold hover:bg-blue-700 transition flex items-center gap-2">
                    <span class="material-symbols-outlined text-sm">content_copy</span> Copy to Clipboard
                </button>
            </div>
        </div>
    </div>

    <div id="req-modal" class="fixed inset-0 bg-black/60 backdrop-blur-sm z-[100] flex items-center justify-center invisible modal">
        <div class="bg-white rounded-2xl shadow-2xl w-11/12 max-w-lg p-6 transform scale-out modal-content">
            <div class="flex justify-between items-center mb-4 border-b pb-2">
                <h3 class="text-xl font-bold text-gray-800 flex items-center gap-2">
                    <span class="material-symbols-outlined text-purple-500">checklist</span> Changes & Requirements
                </h3>
                <button id="close-req" class="text-gray-400 hover:text-gray-800 p-2 hover:bg-gray-100 rounded-full transition-colors">
                    <span class="material-symbols-outlined">close</span>
                </button>
            </div>
            <div class="overflow-y-auto max-h-[60vh] space-y-3 text-sm text-gray-700">
                <p class="font-bold text-gray-900">v13.1 Changelog (Sync & Fidelity):</p>
                <ul class="list-decimal pl-5 space-y-1">
                    <li><strong>Recording Sync:</strong> Background audio now routed via Web Audio API for perfect visual sync.</li>
                    <li><strong>High Fidelity:</strong> Canvas now renders at native Device Pixel Ratio (Retina/4K support).</li>
                    <li><strong>Telemetry:</strong> Added LA Timezone conversion (c19) to payload.</li>
                </ul>
            </div>
        </div>
    </div>

    <div id="autoplay-modal" class="fixed inset-0 bg-black/60 backdrop-blur-sm z-[100] flex items-center justify-center invisible modal">
        <div class="bg-white rounded-2xl shadow-2xl w-11/12 max-w-2xl p-6 transform scale-out modal-content flex flex-col gap-4">
            <div class="flex justify-between items-center mb-2 border-b pb-2">
                <h3 class="text-xl font-bold text-gray-800 flex items-center gap-2">
                    <span class="material-symbols-outlined text-indigo-500">autoplay</span> Auto-Play Studio
                </h3>
                <button id="close-autoplay" class="text-gray-400 hover:text-gray-800 p-2 hover:bg-gray-100 rounded-full transition-colors">
                    <span class="material-symbols-outlined">close</span>
                </button>
            </div>
            <p class="text-sm text-gray-600">Dial in hands-free play, save your presets locally, and load them by prefix without touching JSON.</p>
            <div class="grid md:grid-cols-2 gap-4">
                <div class="space-y-4">
                    <div>
                        <div class="flex justify-between text-xs font-bold text-gray-500 uppercase"><span>Events per Minute</span><span id="auto-rate-label">60</span></div>
                        <input type="range" id="auto-rate" min="10" max="200" value="60" class="w-full">
                    </div>
                    <div>
                        <div class="flex justify-between text-xs font-bold text-gray-500 uppercase"><span>Randomness</span><span id="auto-random-label">40%</span></div>
                        <input type="range" id="auto-random" min="0" max="100" value="40" class="w-full">
                    </div>
                    <div>
                        <div class="flex justify-between text-xs font-bold text-gray-500 uppercase"><span>Chord Chance</span><span id="auto-chord-label">20%</span></div>
                        <input type="range" id="auto-chord" min="0" max="100" value="20" class="w-full">
                    </div>
                    <label class="flex items-center gap-2 text-sm text-gray-700">
                        <input id="auto-drags" type="checkbox" class="rounded border-gray-300 text-indigo-600"> Include drags (sparingly)
                    </label>
                    <label class="flex items-center gap-2 text-sm text-gray-700">
                        <input id="auto-soundscape" type="checkbox" class="rounded border-gray-300 text-indigo-600"> Favor melodic sequences
                    </label>
                </div>
                <div class="space-y-3">
                    <div class="flex items-center gap-2 text-sm">
                        <label class="text-xs font-bold text-gray-500 uppercase">Preset</label>
                        <select id="auto-preset" class="flex-1 border border-gray-200 rounded px-2 py-1 text-sm">
                            <option value="calm">Calm Drift</option>
                            <option value="balanced">Balanced</option>
                            <option value="intense">Bloom Storm</option>
                        </select>
                        <button id="auto-save-preset" class="px-3 py-2 bg-indigo-50 text-indigo-700 rounded text-xs font-bold border border-indigo-200 hover:bg-indigo-100">Save</button>
                    </div>
                    <div class="flex gap-2">
                        <button id="auto-toggle" class="flex-1 py-3 bg-indigo-600 text-white rounded-lg font-bold hover:bg-indigo-700 transition flex items-center justify-center gap-2">
                            <span class="material-symbols-outlined text-sm" id="auto-toggle-icon">play_arrow</span>
                            <span id="auto-toggle-label">Start</span>
                        </button>
                    </div>
                    <div class="bg-gray-50 border border-gray-200 rounded-lg p-3 space-y-2 text-xs text-gray-700">
                        <div class="flex items-center gap-2">
                            <label class="font-bold text-gray-600 text-[11px] uppercase">Prefix</label>
                            <input id="auto-file-prefix" class="flex-1 border border-gray-200 rounded px-2 py-1 text-xs" value="you-" placeholder="prefix-">
                        </div>
                        <div class="flex items-center gap-2">
                            <input id="auto-file-name" class="flex-1 border border-gray-200 rounded px-2 py-1 text-xs" placeholder="gentle-drift">
                            <button id="auto-save-file" class="px-3 py-2 bg-white border border-gray-200 rounded font-semibold hover:bg-gray-100 text-[11px]">Save</button>
                        </div>
                        <div class="flex items-center gap-2">
                            <select id="auto-file-chooser" class="flex-1 border border-gray-200 rounded px-2 py-2 text-xs bg-white"></select>
                            <button id="auto-load-file" class="px-3 py-2 bg-indigo-50 text-indigo-700 rounded font-bold border border-indigo-200 hover:bg-indigo-100 text-[11px]">Load</button>
                        </div>
                        <p class="text-[11px] text-gray-500">Saved files are filtered by prefix above and sorted automatically.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <button id="auto-run-icon" class="fixed bottom-20 right-5 w-12 h-12 bg-indigo-500/80 text-white rounded-full shadow-xl flex items-center justify-center z-40 backdrop-blur hover:scale-105 active:scale-95 transition-all border border-white/30">
        <span class="material-symbols-outlined">autoplay</span>
    </button>

    <script>
        /**
         * A Gift for You - Penang 2026 (Baseline + Injection)
         */

        // --- 1. Core Config & State ---
        const GOOGLE_SHEET_SPLASH_CSV = "https://docs.google.com/spreadsheets/d/1lSxTIZbtXWdxCUWqdqan-hCV1f5_aWQCoV-HXSRHxng/edit?usp=drivesdk";
        const config = {
            currentThemeIndex: 0,
            defaultWords: [
                "Peace", "Gentle", "Warmth", "Love", "Hope", "Empathy", "Calm", "Grace", "Kindness", "Light", "Joy", "Bliss",
                "Serenity", "Breathe Deep", "Be Here", "Soften", "Let Go", "â¤ï¸â¤ï¸â¤ï¸", "ðŸª·ðŸª·ðŸª·", "Balance", "Harmony",
                "Inner Peace", "Radiate", "Stillness", "Presence", "Gratitude", "Acceptance", "Flow", "Healing", "Strength",
                "Wisdom", "Patience", "Courage", "Hi You  :)", "Clarity", "Unity", "Wholeness","Youà¸›à¸£à¸°à¸ªà¸šà¸„à¸§à¸²à¸¡à¸ªà¸³à¹€à¸£à¹‡à¸ˆ","à¸„à¸§à¸²à¸¡à¸ªà¸¸à¸‚à¸¢à¹ˆà¸­à¸¡à¸„à¸¹à¹ˆà¸„à¸§à¸£à¸à¸±à¸šà¸„à¸§à¸²à¸¡à¸ªà¸‡à¸šà¸ªà¸¸à¸‚à¹à¸¥à¸°à¸„à¸§à¸²à¸¡à¹€à¸ˆà¸£à¸´à¸à¸£à¸¸à¹ˆà¸‡à¹€à¸£à¸·à¸­à¸‡","â¤ï¸â¤ï¸â¤ï¸","You ðŸª·à¹€à¸à¸µà¹ˆà¸¢à¸§à¸”à¸­à¸‡à¸à¸±à¸™","You ðŸµï¸ ","à¸­à¸²à¸—à¸£ ðŸŒ¼","à¸­à¸²à¸—à¸£","à¸ˆà¸´à¸•à¸§à¸´à¸à¸à¸²à¸“à¸—à¸µà¹ˆà¸‡à¸”à¸‡à¸²à¸¡"
            ],
            customWords: [],
            speedMultiplier: 1.0,
            decayValue: 0.005,
            trailDecay: 0.01,
            trailSpeed: 1.0,
            useGradient: true,
            backgroundImage: null,
            // Trail State
            currentTrail: 'â™¥',
            lastTrailSwitch: Date.now()
        };

        const themes = [
            { bg: ['#e0c3fc', '#8ec5fc'], text: '#4a148c' },
            { bg: ['#fad0c4', '#ffd1ff'], text: '#880e4f' },
            { bg: ['#d299c2', '#fef9d7'], text: '#3e2723' },
            { bg: ['#a1c4fd', '#c2e9fb'], text: '#01579b' },
            { bg: ['#d4fc79', '#96e6a1'], text: '#1b5e20' }
        ];

        const secretWords = [
            "I Love You", "You are my Sunshine", "I Love You My Sweetheart", "â¤ï¸â¤ï¸â¤ï¸", "ðŸ¥°â¤ï¸â™¥ï¸ðŸ§¡ðŸ«°","whereever you go that's where I want to be", "Forever Yours", "My One and Only", "Soulmate", "Endless Love","My Heart is Yours", "Together Always", "You Complete Me", "My Happy Place", "Love of My Life", "Dream Come True","My Everything", "Cherished", "Adored", "My Rock", "Purest Love", "Only You", "Sweetheart", "Darling",
            "Beloved", "My Angel", "Home is You", "Infinite Love", "Unconditional", "My Better Half", "Twin Flame"
        ];
        
        const sessionLog = [];
        const SESSION_LOG_LIMIT = 200;
        const sessionLifecycle = {
            id: Date.now().toString(36),
            startedAt: Date.now(),
            endedAt: null,
            endReason: null
        };
        const sessionLogFeed = document.getElementById('session-log-feed');
        const pipelineStatusEl = document.getElementById('pipeline-status');
        let pipelineSendCount = 0;

        function fmtTime(ts) {
            const d = new Date(ts);
            return `${d.toLocaleTimeString([], { hour12: false })}.${String(d.getMilliseconds()).padStart(3, '0')}`;
        }

        function setPipelineStatus(label, tone = 'muted') {
            if (!pipelineStatusEl) return;
            pipelineStatusEl.textContent = label;
            pipelineStatusEl.className = 'text-[10px] px-2 py-1 rounded-full';
            if (tone === 'success') pipelineStatusEl.classList.add('bg-emerald-100','text-emerald-700','border','border-emerald-200');
            else if (tone === 'warn') pipelineStatusEl.classList.add('bg-amber-100','text-amber-700','border','border-amber-200');
            else if (tone === 'error') pipelineStatusEl.classList.add('bg-red-100','text-red-700','border','border-red-200');
            else pipelineStatusEl.classList.add('bg-slate-200','text-slate-600');
        }

        function appendSessionLog(type, detail, options = {}) {
            if (options.skipLog) return;
            const entry = { ts: Date.now(), type, detail: (detail ?? '').toString() };
            sessionLog.push(entry);
            if (sessionLog.length > SESSION_LOG_LIMIT) sessionLog.shift();
            renderSessionLog();
        }

        function renderSessionLog() {
            if (!sessionLogFeed) return;
            sessionLogFeed.innerHTML = '';
            const recent = sessionLog.slice(-30);
            if (!recent.length) {
                const p = document.createElement('p');
                p.className = 'text-slate-400';
                p.textContent = 'No activity yet.';
                sessionLogFeed.appendChild(p);
                return;
            }
            recent.forEach(item => {
                const row = document.createElement('p');
                row.className = 'text-slate-600';
                row.textContent = `[${fmtTime(item.ts)}] ${item.type}: ${item.detail}`;
                sessionLogFeed.appendChild(row);
            });
        }

        const SESSION_CLOSE_GRACE_MS = 30000;
        let sessionFlushTimer = null;
        let sessionEndHoldTimer = null;
        let pendingSessionEndReason = null;

        function scheduleSessionFlush(reason) {
            clearTimeout(sessionFlushTimer);
            sessionFlushTimer = setTimeout(() => completeSession(reason), SESSION_CLOSE_GRACE_MS);
            appendSessionLog('session-lifecycle', `Pending end (${reason}) in ${Math.round(SESSION_CLOSE_GRACE_MS/1000)}s.`);
        }

        function requestSessionEnd(reason = 'pagehide', immediate = false) {
            if (logSent) return;
            if (immediate) {
                if (sessionEndHoldTimer) {
                    clearInterval(sessionEndHoldTimer);
                    sessionEndHoldTimer = null;
                }
                completeSession(reason);
                return;
            }
            scheduleSessionFlush(reason);
        }

        function cancelSessionEnd(reason = 'resume') {
            if (sessionFlushTimer) {
                clearTimeout(sessionFlushTimer);
                sessionFlushTimer = null;
            }
            if (sessionEndHoldTimer) {
                clearInterval(sessionEndHoldTimer);
                sessionEndHoldTimer = null;
            }
            pendingSessionEndReason = null;
            appendSessionLog('session-lifecycle', `End cancelled (${reason}).`);
        }

        function completeSession(reason = 'pagehide') {
            if (sessionFlushTimer) {
                clearTimeout(sessionFlushTimer);
                sessionFlushTimer = null;
            }
            if (sessionEndHoldTimer) {
                clearInterval(sessionEndHoldTimer);
                sessionEndHoldTimer = null;
            }
            if (!sessionLifecycle.endedAt) {
                sessionLifecycle.endedAt = Date.now();
                sessionLifecycle.endReason = reason;
                appendSessionLog('session-end', `Ended (${reason}).`);
            }
            logSession(reason);
        }

        renderSessionLog();
        appendSessionLog('session-start', `Experience loaded. Session ID ${sessionLifecycle.id}`);
        setPipelineStatus('Idle');

        let currentBgData = localStorage.getItem('garden_bg') || null;
        let visualEntities = [];
        let wordEntities = [];
        let particles = []; 
        let foundEggs = JSON.parse(localStorage.getItem('garden_egg_ids') || "[]");
        let inputBuffer = ""; 

        // --- 2. Audio Engine (MODIFIED: High Register + Routing) ---
        const ZenAudio = {
            ctx: null, enabled: true, masterGain: null, dest: null, bgNode: null,
            // MODIFIED: Raised lower register (E4+) without boosting upper range
            scale: [329.63, 369.99, 392.00, 440.00, 493.88, 523.25, 587.33, 659.25, 739.99, 880.00, 987.77, 1174.66, 1318.51],
            
            init: function() {
                if (!this.ctx && (window.AudioContext || window.webkitAudioContext)) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.gain.value = 0.3; // Standard Volume
                    
                    this.dest = this.ctx.createMediaStreamDestination();
                    this.masterGain.connect(this.ctx.destination);
                    this.masterGain.connect(this.dest);
                }
            },

            // Connect external HTML Audio Element to Web Audio Graph for Sync Recording
            connectBackground: function(audioEl) {
                if (!this.ctx) this.init();
                if (this.bgNode) return; // Already connected
                
                try {
                    // Create source from the <audio> element
                    this.bgNode = this.ctx.createMediaElementSource(audioEl);
                    // Connect to masterGain (which goes to speakers AND recorder)
                    this.bgNode.connect(this.masterGain);
                } catch(e) {
                    console.error("Audio routing failed (likely CORS or state):", e);
                }
            },

            // Instant Wake Up (Fixes 1st Drag Mute)
            warmUp: function() {
                if (!this.ctx) this.init();
                if (this.ctx && (this.ctx.state === 'suspended' || this.ctx.state === 'interrupted')) {
                    this.ctx.resume();
                }
                
                if (this.ctx && this.enabled) {
                    // Play imperceptible silence to force hardware engage
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    gain.gain.value = 0.001; 
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.01);
                }
            },

            getFreqIndex: function(y, height) {
                const norm = 1 - Math.max(0, Math.min(1, y / height));
                return Math.floor(norm * (this.scale.length - 1));
            },
            
            // Classic Karplus-Strong Pluck
            playPluck: function(freq, volume = 0.3) {
                if (!this.ctx || !this.enabled) return;
                if (this.ctx.state !== 'running') this.ctx.resume().catch(()=>{});

                const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 2.0, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                const delayLength = Math.floor(this.ctx.sampleRate / freq);
                let idx = 0, last = 0;
                
                // Burst
                const noise = new Float32Array(delayLength).map(() => Math.random()*2-1);
                
                for (let i = 0; i < buffer.length; i++) {
                    // 0.99 Decay for "Classic" cleaner sound (vs 0.992 metallic)
                    const sample = (noise[idx] + last) * 0.5 * 0.99; 
                    last = noise[idx]; noise[idx] = sample;
                    data[i] = sample * volume;
                    idx = (idx + 1) % delayLength;
                }
                const src = this.ctx.createBufferSource(); src.buffer = buffer; src.connect(this.masterGain); src.start();
            },
            
            // Harmonious Triad Strum (Double Tap)
            playChord: function(baseIdx) {
                if (!this.ctx || !this.enabled) return;
                // Root
                this.playPluck(this.scale[baseIdx], 0.2);
                // 3rd (approx)
                setTimeout(() => {
                    const idx2 = Math.min(this.scale.length-1, baseIdx + 2);
                    this.playPluck(this.scale[idx2], 0.15);
                }, 40);
                // 5th (approx)
                setTimeout(() => {
                    const idx3 = Math.min(this.scale.length-1, baseIdx + 4);
                    this.playPluck(this.scale[idx3], 0.15);
                }, 80);
            },
            
            playDiscovery: function() {
                if (!this.ctx || !this.enabled) return;
                [261.63, 329.63, 392.00, 523.25].forEach((f, i) => { setTimeout(() => this.playPluck(f, 0.2), i * 150); });
            }
        };

        // --- 3. Graphics & Entities ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        function resize() {
            // HIGH FIDELITY UPDATE: Respect Device Pixel Ratio
            const dpr = window.devicePixelRatio || 1;
            width = window.innerWidth;
            height = window.innerHeight;
            
            // Set internal buffer size to native resolution
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            
            // Scale context so drawing logic remains in CSS pixels
            ctx.scale(dpr, dpr);
            
            document.getElementById('settings-panel').style.height = `${window.innerHeight}px`;
        }
        window.addEventListener('resize', resize);
        window.addEventListener('orientationchange', () => { setTimeout(resize, 100); });
        resize();

        const random = (min, max) => Math.random() * (max - min) + min;
        function getPastelColor() { 
            const hue = random(0, 360);
            return { hue: hue, str: `hsla(${hue}, 70%, 80%,` };
        }
        function getRandomWord() {
            if (config.customWords.length > 0) return config.customWords[Math.floor(Math.random() * config.customWords.length)];
            return config.defaultWords[Math.floor(Math.random() * config.defaultWords.length)];
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y;
                this.vx = random(-3, 3); this.vy = random(-5, 1);
                this.life = 1.0; this.decay = random(0.005, 0.02);
                this.color = color;
                this.gravity = 0.1;
                this.sparkleColor = `hsl(${random(0,360)}, 80%, 70%)`;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.vy += this.gravity;
                this.life -= this.decay;
            }
            draw(ctx) {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.sparkleColor;
                ctx.fillRect(this.x, this.y, 2, 2);
            }
            isDead() { return this.life <= 0; }
        }

        class Word {
            constructor(x, y, text) {
                this.x = x; this.y = y; this.text = text || getRandomWord();
                this.velocity = -0.5; this.alpha = 0; this.fadeIn = true;
                this.color = themes[config.currentThemeIndex].text; 
            }
            update() {
                this.y += this.velocity * config.speedMultiplier;
                if (this.fadeIn) { this.alpha += 0.02 * config.speedMultiplier; if (this.alpha>=1) this.fadeIn=false; } 
                else if (config.decayValue > 0) { this.alpha -= config.decayValue * config.speedMultiplier; }
            }
            draw(ctx) {
                ctx.save(); ctx.globalAlpha = Math.max(0, this.alpha);
                ctx.font = "20px 'Segoe UI', sans-serif"; ctx.fillStyle = this.color;
                ctx.textAlign = "center"; ctx.shadowBlur = 4; ctx.shadowColor = "rgba(0,0,0,0.5)";
                ctx.fillText(this.text, this.x, this.y); ctx.restore();
            }
            isDead() { return this.alpha <= 0 && !this.fadeIn; }
        }

        class Bloom {
            constructor(x, y, size=null) {
                this.x = x; this.y = y; this.size = 0; 
                this.maxSize = size || random(30, 80);
                this.colorObj = getPastelColor();
                this.colorBase = this.colorObj.str;
                this.petals = Math.floor(random(5, 9));
                this.alpha = 1; 
                this.compColor = `hsla(${(this.colorObj.hue + 180)%360}, 60%, 70%,`;
                this.rotation = random(0, Math.PI*2);
                const shapeRnd = Math.random();
                if(shapeRnd > 0.6) this.shape = 'pointed';
                else if (shapeRnd > 0.3) this.shape = 'round';
                else this.shape = 'hybrid';
            }
            update() {
                this.rotation += 0.002;
                if (this.size < this.maxSize) this.size += 0.5 * config.speedMultiplier;
                else if (config.decayValue > 0) this.alpha -= config.decayValue * config.speedMultiplier;
            }
            draw(ctx) {
                ctx.save();
                
                // Secret 2: Gold Filigree
                if(foundEggs.includes(2)) {
                    ctx.strokeStyle = `rgba(218, 165, 32, ${this.alpha * 0.6})`;
                    ctx.lineWidth = 0.5;
                    for(let i=0; i<5; i++) {
                        const angle = (i/5) * Math.PI*2 + this.rotation;
                        const len = this.size * 1.5;
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.bezierCurveTo(this.x + Math.cos(angle - 0.4) * len * 0.5, this.y + Math.sin(angle - 0.4) * len * 0.5,
                            this.x + Math.cos(angle + 0.4) * len * 0.8, this.y + Math.sin(angle + 0.4) * len * 0.8,
                            this.x + Math.cos(angle) * len, this.y + Math.sin(angle) * len);
                        ctx.stroke(); 
                    }
                }

                for(let i=0; i<3; i++) {
                    ctx.fillStyle = this.colorBase + (this.alpha * 0.7 * (1 - i*0.2)) + ')';
                    ctx.beginPath();
                    for (let j = 0; j < this.petals; j++) {
                        const angle = (j / this.petals) * Math.PI * 2 + (i * 0.1) + this.rotation;
                        const petalSize = (this.size - (i*5));
                        if (petalSize <= 0) continue;
                        
                        ctx.moveTo(this.x, this.y);
                        if(this.shape === 'pointed') {
                            ctx.quadraticCurveTo(
                                this.x + Math.cos(angle - 0.3) * petalSize, 
                                this.y + Math.sin(angle - 0.3) * petalSize,
                                this.x + Math.cos(angle) * petalSize * 1.2,
                                this.y + Math.sin(angle) * petalSize * 1.2
                            );
                            ctx.quadraticCurveTo(
                                this.x + Math.cos(angle + 0.3) * petalSize,
                                this.y + Math.sin(angle + 0.3) * petalSize,
                                this.x, this.y
                            );
                        } else {
                            ctx.ellipse(this.x + Math.cos(angle)*(petalSize*0.5), this.y + Math.sin(angle)*(petalSize*0.5), petalSize*0.4, petalSize*0.2, angle, 0, Math.PI*2);
                        }
                    }
                    ctx.fill();
                }

                // Ornate Center
                const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size * 0.25);
                const centerAlpha = foundEggs.includes(1) ? 0.9 : 0.7; 
                grad.addColorStop(0, `rgba(255, 255, 255, ${centerAlpha})`); 
                grad.addColorStop(0.4, this.compColor + (this.alpha * centerAlpha) + ")"); 
                grad.addColorStop(1, this.compColor + "0)"); 
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size * 0.25, 0, Math.PI*2); ctx.fill();
                
                ctx.strokeStyle = `rgba(255,255,255,${this.alpha*0.6})`;
                ctx.lineWidth = 1;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size*0.1, 0, Math.PI*2); ctx.stroke();
                
                if(this.size > 20) {
                    ctx.fillStyle = `rgba(255,255,200,${this.alpha})`;
                    for(let k=0; k<6; k++) {
                        const dotA = (k/6)*Math.PI*2 + this.rotation;
                        const dotR = this.size * 0.2;
                        ctx.beginPath(); ctx.arc(this.x + Math.cos(dotA)*dotR, this.y + Math.sin(dotA)*dotR, 1.5, 0, Math.PI*2); ctx.fill();
                    }
                }

                ctx.restore();
            }
            isDead() { 
                if (this.alpha <= 0 && foundEggs.includes(5)) {
                    for(let k=0; k<15; k++) particles.push(new Particle(this.x, this.y, this.colorBase + '1)'));
                }
                return this.alpha <= 0; 
            }
        }

        class GrowingHeart {
            constructor(x, y) {
                this.x = x; this.y = y; this.size = 0; 
                this.maxSize = random(40, 90);
                this.hue = random(0, 360);
                this.alpha = 1;
            }
            update() {
                if (this.size < this.maxSize) this.size += 0.5 * config.speedMultiplier;
                else if (config.decayValue > 0) this.alpha -= config.decayValue * config.speedMultiplier;
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                const scale = this.size / 30;
                ctx.scale(scale, scale);
                ctx.globalAlpha = Math.max(0, this.alpha);

                let grad = ctx.createRadialGradient(-5, -5, 2, 0, 0, 25);
                grad.addColorStop(0, "white"); 
                grad.addColorStop(0.3, `hsl(${this.hue}, 100%, 70%)`); 
                grad.addColorStop(1, `hsl(${this.hue}, 100%, 30%)`); 
                ctx.fillStyle = grad;

                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.bezierCurveTo(-10, -10, -20, 0, 0, 20);
                ctx.bezierCurveTo(20, 0, 10, -10, 0, 0);
                ctx.fill();
                
                ctx.strokeStyle = `rgba(255,255,255,${this.alpha*0.5})`;
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.restore();
            }
            isDead() { return this.alpha <= 0; }
        }

        class HeartBloom extends Bloom {
            draw(ctx) {
                ctx.save();
                const layerCount = foundEggs.includes(3) ? 5 : 3;
                for(let i=0; i<layerCount; i++) {
                    const scale = (this.size - (i*4)) / 20;
                    if (scale <= 0) continue;
                    const pCount = this.petals + (i%2); 
                    for (let j = 0; j < pCount; j++) {
                        ctx.save();
                        const angle = (j / pCount) * Math.PI * 2 + this.rotation + (i*0.2);
                        ctx.translate(this.x, this.y);
                        ctx.rotate(angle + Math.PI/2);
                        ctx.translate(0, -scale * 15);
                        ctx.scale(scale, scale);
                        
                        let grad = ctx.createRadialGradient(-3, -3, 1, 0, 0, 15);
                        grad.addColorStop(0, "rgba(255,255,255,0.4)");
                        grad.addColorStop(1, this.colorBase + (this.alpha * 0.8) + ')');
                        ctx.fillStyle = grad;

                        ctx.beginPath();
                        ctx.moveTo(0,0);
                        ctx.bezierCurveTo(-5, -5, -10, 0, 0, 10);
                        ctx.bezierCurveTo(10, 0, 5, -5, 0, 0);
                        ctx.fill();
                        ctx.restore();
                    }
                }
                ctx.fillStyle = this.compColor + this.alpha + ')';
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size * 0.1, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            }
        }

        class HeartCloud {
            constructor(x, y) {
                this.x = x; this.y = y; this.alpha = 1;
                this.hearts = [];
                const count = Math.floor(random(4, 12));
                const colors = ["#ff0000", "#ff7f00", "#ffff00", "#00ff00", "#0000ff", "#4b0082", "#9400d3", "#ff1493"];
                for(let i=0; i<count; i++) {
                    this.hearts.push({
                        ox: random(-40, 40), oy: random(-40, 40),
                        size: random(10, 25),
                        color: colors[Math.floor(Math.random()*colors.length)],
                        rot: random(-0.2, 0.2)
                    });
                }
            }
            update() {
                this.y -= 0.5 * config.speedMultiplier;
                if (config.decayValue > 0) this.alpha -= config.decayValue * config.speedMultiplier;
            }
            draw(ctx) {
                ctx.save(); ctx.globalAlpha = Math.max(0, this.alpha);
                this.hearts.forEach(h => {
                    ctx.save();
                    ctx.translate(this.x + h.ox, this.y + h.oy);
                    ctx.rotate(h.rot);
                    const scale = h.size / 20;
                    ctx.scale(scale, scale);
                    
                    let grad = ctx.createRadialGradient(-5, -5, 2, 0, 0, 20);
                    grad.addColorStop(0, "white");
                    grad.addColorStop(0.3, h.color);
                    grad.addColorStop(1, "#330000"); // Depth
                    ctx.fillStyle = grad;
                    
                    ctx.beginPath();
                    ctx.moveTo(0,0);
                    ctx.bezierCurveTo(-10, -10, -20, 0, 0, 20);
                    ctx.bezierCurveTo(20, 0, 10, -10, 0, 0);
                    ctx.fill();
                    ctx.restore();
                });
                ctx.restore();
            }
            isDead() { return this.alpha <= 0; }
        }

        // --- TRAIL SYSTEM (Vivid & Opaque) ---
        class TrailBase {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.alpha = 1; 
                this.size = random(10, 20);
                this.type = type; 
                this.hue = random(0, 360);
                this.color = `hsl(${this.hue},100%,60%)`; 
                this.cometColor = `hsl(${random(200,260)},100%,80%)`;
            }
            update() {
                this.y -= config.trailSpeed; 
                this.alpha -= config.trailDecay; 
            }
            draw(ctx) {
                ctx.save(); ctx.globalAlpha = Math.max(0, this.alpha);
                
                if(this.type === "Comet") {
                    ctx.fillStyle = this.cometColor;
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.size/3, 0, Math.PI*2); ctx.fill();
                } 
                else if (this.type === "â™¥" || this.type === "â­") {
                    ctx.translate(this.x, this.y);
                    
                    if(this.type === "â™¥") {
                        // 2D Vivid Heart
                        ctx.fillStyle = this.color;
                        ctx.font = `${this.size}px serif`;
                        ctx.fillText("â™¥", 0, 0);
                    } else {
                        // Star
                        ctx.fillStyle = this.color; // Colorful Stars
                        ctx.font = `${this.size}px serif`;
                        ctx.fillText("â­", 0, 0);
                    }
                } 
                else {
                    // Cloud
                    ctx.fillStyle = "rgba(255,255,255,0.9)";
                    ctx.font = `${this.size}px serif`;
                    ctx.fillText(this.type, this.x, this.y);
                }
                ctx.restore();
            }
            isDead() { return this.alpha <= 0; }
        }

        // --- 4. Input Handling ---
        let lastTap=0, lastTapX=null, lastTapY=null, isDragging=false, dragStart=0, startX, startY, lastDragSound=0;
        let lastSyncDragEmit = 0;
        const DOUBLE_TAP_WINDOW = 240; // tighten window to avoid false doubles
        const DOUBLE_TAP_DISTANCE = 40; // require taps to be near each other
        const syncClientId = (crypto.randomUUID && crypto.randomUUID()) || `client-${Date.now().toString(36)}-${Math.random().toString(16).slice(2)}`;
        const SESSION_KEY_PARAM = 'session';
        const SIGNAL_KEY_PARAM = 'signal';
        const p2pStatusEl = document.getElementById('p2p-status');
        const p2pSessionEl = document.getElementById('p2p-session');
        const p2pShareEl = document.getElementById('p2p-share-url');
        const p2pCopyEl = document.getElementById('p2p-copy-url');
        const p2pNewBtn = document.getElementById('p2p-new-session');

        const p2p = {
            clientId: syncClientId,
            session: '',
            signalHttpUrl: '',
            signalWsUrl: '',
            signalParam: '',
            signalWs: null,
            signalPollTimer: null,
            signalPollSince: 0,
            signalSeq: 0,
            signalWsFailures: 0,
            forceHttp: false,
            peers: new Map(),
            inboundSeq: {},
            ready: false,
            lastStateRequestId: '',
            sequence: { live: 0, state: 0 }
        };

        function formatNowWithMs() {
            const d = new Date();
            return `${d.toLocaleTimeString([], { hour12: false })}.${String(d.getMilliseconds()).padStart(3, '0')}`;
        }

        function setP2PStatus(text, tone = 'retry') {
            if (p2pStatusEl) {
                p2pStatusEl.textContent = text;
                p2pStatusEl.className = 'text-[10px] px-2 py-1 rounded-full';
                if (tone === 'ok') p2pStatusEl.classList.add('bg-emerald-100','text-emerald-700','border','border-emerald-200');
                else if (tone === 'error') p2pStatusEl.classList.add('bg-red-100','text-red-700','border','border-red-200');
                else p2pStatusEl.classList.add('bg-slate-200','text-slate-600');
            }
            setPipelineStatus(text, tone === 'ok' ? 'success' : tone === 'error' ? 'error' : 'warn');
        }

        function randomSession() {
            return `gift-${Math.random().toString(36).slice(2, 8)}`;
        }

        function computeSignalUrls(raw) {
            let input = raw;
            if (!input) {
                const base = new URL(window.location.origin);
                base.pathname = '/signal';
                return { httpUrl: base.toString(), wsUrl: base.toString().replace(/^http/, 'ws') };
            }
            if (!/^https?:\/\//i.test(input) && !/^wss?:\/\//i.test(input)) {
                input = `https://${input}`;
            }
            const url = new URL(input);
            if (!url.pathname || url.pathname === '/') {
                url.pathname = '/signal';
            }
            const httpUrl = url.toString().replace(/^ws/i, 'http');
            const wsUrl = url.toString().replace(/^http/i, 'ws');
            return { httpUrl, wsUrl };
        }

        function buildShareLink(session) {
            const url = new URL(window.location.href);
            url.searchParams.set(SESSION_KEY_PARAM, session);
            if (p2p.signalParam) url.searchParams.set(SIGNAL_KEY_PARAM, p2p.signalParam);
            else url.searchParams.delete(SIGNAL_KEY_PARAM);
            return url.toString();
        }

        function resolveSession() {
            const url = new URL(window.location.href);
            const urlSession = (url.searchParams.get(SESSION_KEY_PARAM) || '').trim();
            const urlSignal = (url.searchParams.get(SIGNAL_KEY_PARAM) || '').trim();
            p2p.session = urlSession || randomSession();
            p2p.signalParam = urlSignal;
            const { httpUrl, wsUrl } = computeSignalUrls(urlSignal);
            p2p.signalHttpUrl = httpUrl;
            p2p.signalWsUrl = wsUrl;
            url.searchParams.set(SESSION_KEY_PARAM, p2p.session);
            if (p2p.signalParam) url.searchParams.set(SIGNAL_KEY_PARAM, p2p.signalParam);
            else url.searchParams.delete(SIGNAL_KEY_PARAM);
            history.replaceState(null, '', url.toString());
            if (p2pSessionEl) p2pSessionEl.value = p2p.session;
            const share = buildShareLink(p2p.session);
            if (p2pShareEl) {
                p2pShareEl.textContent = share;
                p2pShareEl.dataset.url = share;
            }
        }

        function copyShareUrl() {
            const value = p2pShareEl?.dataset.url || '';
            if (!value) return;
            navigator.clipboard?.writeText(value).then(() => setP2PStatus('URL copied', 'ok')).catch(() => setP2PStatus('Copy failed', 'error'));
        }

        function addSyncLog(direction, text, latencyMs = null, channel = '') {
            const latencyLabel = latencyMs == null ? '' : ` â€¢ +${latencyMs}ms`;
            const channelLabel = channel ? `[${channel}] ` : '';
            appendSessionLog(direction, `${channelLabel}${text} (${formatNowWithMs()}${latencyLabel})`);
        }

        function broadcastSync(payload, channel, targetPeerId = null) {
            const serialized = JSON.stringify(payload);
            const peers = targetPeerId ? [p2p.peers.get(targetPeerId)].filter(Boolean) : Array.from(p2p.peers.values());
            peers.forEach(peer => {
                const dataChannel = channel === 'state' ? peer.stateChannel : peer.liveChannel;
                if (!dataChannel) return;
                if (dataChannel.readyState === 'open') {
                    dataChannel.send(serialized);
                } else {
                    peer.pending[channel].push(serialized);
                }
            });
        }

        function sendSync(type, value = {}, channel = 'live', targetPeerId = null) {
            if (!p2p.session) return;
            const ts = Date.now();
            const seq = (p2p.sequence[channel] || 0) + 1;
            p2p.sequence[channel] = seq;
            const payload = { session: p2p.session, type, value, ts, seq, channel, clientId: p2p.clientId };
            addSyncLog('you', `${type}: ${JSON.stringify(value)} (#${seq})`, null, channel);
            broadcastSync(payload, channel, targetPeerId);
        }

        function applyStateSnapshot(state = {}) {
            if (state.background) applyBackgroundStateFromPeer(state.background);
            if (typeof state.themeIndex === 'number') config.currentThemeIndex = state.themeIndex % themes.length;
            if (typeof state.audioEnabled === 'boolean') {
                ZenAudio.enabled = state.audioEnabled;
                const audioToggle = document.getElementById('audio-toggle');
                if (audioToggle) audioToggle.checked = ZenAudio.enabled;
            }
            if (state.customWords) {
                config.customWords = Array.isArray(state.customWords) ? state.customWords : [];
                const cBox = document.getElementById('custom-words');
                if (cBox) cBox.value = config.customWords.join(',');
            }
            if (state.trail) config.currentTrail = state.trail;
        }

        function getStateSnapshot() {
            return {
                background: getBackgroundStatePayload(),
                themeIndex: config.currentThemeIndex,
                audioEnabled: ZenAudio.enabled,
                customWords: config.customWords,
                trail: config.currentTrail
            };
        }

        function handleSyncMessage({ payload, channel, peerId }) {
            if (!payload || payload.session !== p2p.session) return;
            const fromSelf = payload.clientId && payload.clientId === p2p.clientId;
            if (fromSelf) return;
            const ts = payload.ts || Date.now();
            const seq = payload.seq || 0;
            const latencyMs = Math.max(0, Date.now() - ts);
            const peerKey = peerId || payload.clientId || 'peer';
            if (!p2p.inboundSeq[peerKey]) {
                p2p.inboundSeq[peerKey] = { live: { seq: 0, ts: 0 }, state: { seq: 0, ts: 0 } };
            }
            const channelKey = channel || payload.channel || 'live';
            const lastState = p2p.inboundSeq[peerKey][channelKey] || { seq: 0, ts: 0 };
            if (seq <= lastState.seq) return;
            p2p.inboundSeq[peerKey][channelKey] = { seq, ts: Math.max(lastState.ts, ts) };
            applySyncEvent(payload);
            addSyncLog('peer', `${payload.type}: ${JSON.stringify(payload.value)} (#${seq})`, latencyMs, channelKey);
        }

        function applySyncEvent(payload) {
            const { type, value = {}, clientId } = payload;
            if (type === 'tap') {
                simulateTap(value.x, value.y, { silentSync: true, sharedWord: value.word, sharedVisual: value.visual, forceDouble: value.double });
            } else if (type === 'drag') {
                simulateDrag(value.x1, value.y1, value.x2, value.y2, { silentSync: true, sharedTrail: value.trail });
            } else if (type === 'background') {
                applyBackgroundStateFromPeer(value);
            } else if (type === 'audio') {
                ZenAudio.enabled = !!value.enabled;
                const audioToggle = document.getElementById('audio-toggle');
                if (audioToggle) audioToggle.checked = ZenAudio.enabled;
            } else if (type === 'custom-words') {
                config.customWords = Array.isArray(value.words) ? value.words : [];
                const cBox = document.getElementById('custom-words');
                if (cBox) cBox.value = config.customWords.join(',');
            } else if (type === 'state-sync') {
                if (value.target && value.target !== p2p.clientId) return;
                applyStateSnapshot(value.state || {});
            } else if (type === 'state-request') {
                if (p2p.lastStateRequestId === value.requestId) return;
                p2p.lastStateRequestId = value.requestId;
                sendSync('state-sync', { state: getStateSnapshot(), target: clientId }, 'state', clientId);
            }
        }

        function updatePeerStatus() {
            const peers = Array.from(p2p.peers.values());
            const liveReady = peers.filter(peer => peer.ready.live).length;
            const stateReady = peers.filter(peer => peer.ready.state).length;
            if (liveReady || stateReady) {
                setP2PStatus(`Connected (${liveReady} live / ${stateReady} state)`, 'ok');
                p2p.ready = true;
            } else if (p2p.signalWs && p2p.signalWs.readyState === WebSocket.OPEN) {
                setP2PStatus('Waiting for peersâ€¦', 'retry');
            } else {
                setP2PStatus('Signalingâ€¦', 'retry');
            }
        }

        function flushPending(peer, channelKey) {
            const dataChannel = channelKey === 'state' ? peer.stateChannel : peer.liveChannel;
            if (!dataChannel || dataChannel.readyState !== 'open') return;
            const queue = peer.pending[channelKey];
            while (queue.length) {
                dataChannel.send(queue.shift());
            }
        }

        function setupDataChannel(peer, channel, channelKey) {
            channel.onopen = () => {
                peer.ready[channelKey] = true;
                flushPending(peer, channelKey);
                updatePeerStatus();
                if (channelKey === 'state') {
                    sendSync('state-request', { requestId: crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2, 10) }, 'state', peer.id);
                }
            };
            channel.onclose = () => {
                peer.ready[channelKey] = false;
                updatePeerStatus();
            };
            channel.onerror = () => updatePeerStatus();
            channel.onmessage = event => {
                try {
                    const payload = JSON.parse(event.data);
                    handleSyncMessage({ payload, channel: channelKey, peerId: peer.id });
                } catch (e) {
                    console.warn('datachannel parse error', e);
                }
            };
        }

        function ensurePeer(remoteId) {
            if (p2p.peers.has(remoteId)) return p2p.peers.get(remoteId);
            const pc = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });
            const peer = {
                id: remoteId,
                pc,
                liveChannel: null,
                stateChannel: null,
                pending: { live: [], state: [] },
                ready: { live: false, state: false },
                makingOffer: false,
                isSettingRemoteAnswerPending: false,
                ignoreOffer: false,
                initiator: p2p.clientId < remoteId,
                polite: p2p.clientId > remoteId,
                hasOffered: false
            };
            p2p.peers.set(remoteId, peer);

            pc.onicecandidate = event => {
                if (event.candidate) {
                    sendSignal('ice', { candidate: event.candidate }, remoteId);
                }
            };
            pc.onconnectionstatechange = () => {
                if (['failed', 'disconnected', 'closed'].includes(pc.connectionState)) {
                    updatePeerStatus();
                }
            };
            pc.ondatachannel = event => {
                const channel = event.channel;
                if (channel.label === 'live') {
                    peer.liveChannel = channel;
                    setupDataChannel(peer, channel, 'live');
                } else if (channel.label === 'state') {
                    peer.stateChannel = channel;
                    setupDataChannel(peer, channel, 'state');
                }
            };

            if (peer.initiator) {
                peer.liveChannel = pc.createDataChannel('live', { ordered: false, maxRetransmits: 0 });
                peer.stateChannel = pc.createDataChannel('state', { ordered: true });
                setupDataChannel(peer, peer.liveChannel, 'live');
                setupDataChannel(peer, peer.stateChannel, 'state');
            }
            updatePeerStatus();
            return peer;
        }

        async function negotiateOffer(peer) {
            try {
                peer.makingOffer = true;
                await peer.pc.setLocalDescription(await peer.pc.createOffer());
                sendSignal('offer', { description: peer.pc.localDescription }, peer.id);
                peer.hasOffered = true;
            } catch (e) {
                console.warn('offer failed', e);
            } finally {
                peer.makingOffer = false;
            }
        }

        async function handleOffer(peer, description) {
            const readyForOffer = !peer.makingOffer && (peer.pc.signalingState === 'stable' || peer.isSettingRemoteAnswerPending);
            const offerCollision = !readyForOffer;
            peer.ignoreOffer = !peer.polite && offerCollision;
            if (peer.ignoreOffer) return;
            peer.isSettingRemoteAnswerPending = description.type === 'offer';
            await peer.pc.setRemoteDescription(description);
            peer.isSettingRemoteAnswerPending = false;
            if (description.type === 'offer') {
                await peer.pc.setLocalDescription(await peer.pc.createAnswer());
                sendSignal('answer', { description: peer.pc.localDescription }, peer.id);
            }
        }

        async function handleSignalMessage(message) {
            if (!message || message.session !== p2p.session) return;
            if (message.to && message.to !== p2p.clientId) return;
            if (message.from === p2p.clientId) return;
            const remoteId = message.from;
            const peer = ensurePeer(remoteId);
            try {
                if (message.type === 'join') {
                    if (peer.initiator && !peer.hasOffered) {
                        await negotiateOffer(peer);
                    }
                } else if (message.type === 'offer' || message.type === 'answer') {
                    await handleOffer(peer, message.payload.description);
                } else if (message.type === 'ice' && message.payload?.candidate) {
                    try {
                        await peer.pc.addIceCandidate(message.payload.candidate);
                    } catch (e) {
                        if (!peer.ignoreOffer) console.warn('ice error', e);
                    }
                } else if (message.type === 'leave') {
                    closePeer(remoteId);
                }
            } catch (e) {
                console.warn('signal handling error', e);
            }
        }

        function sendSignal(type, payload = {}, to = null) {
            if (!p2p.session) return;
            const message = {
                session: p2p.session,
                from: p2p.clientId,
                to,
                type,
                payload,
                ts: Date.now(),
                seq: ++p2p.signalSeq
            };
            if (p2p.signalWs && p2p.signalWs.readyState === WebSocket.OPEN) {
                p2p.signalWs.send(JSON.stringify(message));
            } else {
                fetch(p2p.signalHttpUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(message)
                }).catch(() => setP2PStatus('Signal send failed', 'error'));
            }
        }

        function connectSignalingWs() {
            if (!p2p.signalWsUrl) return;
            const wsUrl = new URL(p2p.signalWsUrl);
            wsUrl.searchParams.set('session', p2p.session);
            wsUrl.searchParams.set('client', p2p.clientId);
            p2p.signalWs = new WebSocket(wsUrl.toString());
            p2p.signalWs.onopen = () => {
                p2p.signalWsFailures = 0;
                setP2PStatus('Signaling ready', 'ok');
                sendSignal('join');
                updatePeerStatus();
            };
            p2p.signalWs.onmessage = event => {
                try {
                    const data = JSON.parse(event.data);
                    if (Array.isArray(data)) data.forEach(handleSignalMessage);
                    else handleSignalMessage(data);
                } catch (e) {
                    console.warn('signal parse error', e);
                }
            };
            p2p.signalWs.onerror = () => {
                p2p.signalWsFailures += 1;
                if (p2p.signalWsFailures >= 2) p2p.forceHttp = true;
                setP2PStatus('Signaling error', 'warn');
            };
            p2p.signalWs.onclose = () => {
                p2p.signalWs = null;
                scheduleSignalReconnect();
            };
        }

        async function pollSignalHttp() {
            const url = new URL(p2p.signalHttpUrl);
            url.searchParams.set('session', p2p.session);
            url.searchParams.set('client', p2p.clientId);
            if (p2p.signalPollSince) url.searchParams.set('since', p2p.signalPollSince);
            try {
                const res = await fetch(url.toString());
                if (!res.ok) throw new Error('signal poll failed');
                const data = await res.json();
                if (Array.isArray(data)) {
                    data.forEach(msg => {
                        if (msg.seq) p2p.signalPollSince = Math.max(p2p.signalPollSince, msg.seq);
                        handleSignalMessage(msg);
                    });
                }
                setP2PStatus('Signaling ready', 'ok');
            } catch (e) {
                setP2PStatus('Signaling retryâ€¦', 'warn');
            } finally {
                p2p.signalPollTimer = setTimeout(pollSignalHttp, 1200);
            }
        }

        function scheduleSignalReconnect() {
            clearTimeout(p2p.signalPollTimer);
            p2p.signalPollTimer = setTimeout(connectSignaling, 800);
        }

        function connectSignaling() {
            clearTimeout(p2p.signalPollTimer);
            if (p2p.signalWs) {
                try { p2p.signalWs.close(); } catch (_) {}
                p2p.signalWs = null;
            }
            setP2PStatus('Signalingâ€¦', 'retry');
            if (!p2p.forceHttp && 'WebSocket' in window) {
                connectSignalingWs();
            } else {
                sendSignal('join');
                pollSignalHttp();
            }
        }

        function closePeer(peerId) {
            const peer = p2p.peers.get(peerId);
            if (!peer) return;
            try { peer.pc.close(); } catch (_) {}
            p2p.peers.delete(peerId);
            updatePeerStatus();
        }

        function resetSyncSession() {
            const fresh = randomSession();
            const url = new URL(window.location.href);
            url.searchParams.set(SESSION_KEY_PARAM, fresh);
            history.replaceState(null, '', url.toString());
            resolveSession();
            p2p.peers.forEach((_, peerId) => closePeer(peerId));
            p2p.signalWsFailures = 0;
            p2p.forceHttp = false;
            connectSignaling();
        }

        if (p2pCopyEl) p2pCopyEl.addEventListener('click', copyShareUrl);
        if (p2pNewBtn) p2pNewBtn.addEventListener('click', resetSyncSession);

        window.addEventListener('beforeunload', () => sendSignal('leave'));

        resolveSession();
        connectSignaling();

        async function optimizeBackgroundData(dataUrl, { maxEdge = 1280, quality = 0.78, maxBytes = 260000 } = {}) {
            return new Promise(resolve => {
                const img = new Image();
                img.onload = () => {
                    const render = (edge, q) => {
                        const scale = Math.min(1, edge / Math.max(img.width, img.height));
                        const canvas = document.createElement('canvas');
                        canvas.width = Math.max(1, Math.round(img.width * scale));
                        canvas.height = Math.max(1, Math.round(img.height * scale));
                        const ctx = canvas.getContext('2d');
                        if (!ctx) return dataUrl;
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        return canvas.toDataURL('image/jpeg', q);
                    };
                    let edge = maxEdge;
                    let q = quality;
                    let output = render(edge, q);
                    while (output.length > maxBytes && q > 0.5) {
                        q = Math.max(0.5, q - 0.08);
                        output = render(edge, q);
                    }
                    while (output.length > maxBytes && edge > 640) {
                        edge = Math.round(edge * 0.85);
                        q = Math.min(q, 0.7);
                        output = render(edge, q);
                    }
                    resolve(output);
                };
                img.onerror = () => resolve(dataUrl);
                img.src = dataUrl;
            });
        }

        async function setBackgroundImageFromData(dataUrl, { persist = true, notifyOnFail = false, silentSync = false, optimize = false } = {}) {
            if (!dataUrl) return false;
            let persisted = true;
            const preparedData = optimize ? await optimizeBackgroundData(dataUrl) : dataUrl;
            currentBgData = preparedData;
            if (persist) {
                try { localStorage.setItem('garden_bg', preparedData); }
                catch (err) {
                    persisted = false;
                    if (notifyOnFail) alert("Image applied! Note: This image is too large to save permanently, so it will reset if you refresh the page.");
                    console.warn("Image too large to persist; will reset on reload.", err);
                }
            }
            const img = new Image();
            img.onload = ()=>{config.backgroundImage=img;config.useGradient=false;};
            img.src = preparedData;
            if (!silentSync) sendSync('background', getBackgroundStatePayload(), 'state');
            return persisted;
        }

        function resetBackgroundToGradient({ persist = true, silentSync = false } = {}) {
            if (persist) localStorage.removeItem('garden_bg');
            currentBgData = null;
            config.useGradient = true;
            config.backgroundImage = null;
            if (!silentSync) sendSync('background', getBackgroundStatePayload(), 'state');
        }

        function getBackgroundStatePayload() {
            return {
                useGradient: config.useGradient,
                imageData: config.useGradient ? null : currentBgData,
                ts: Date.now()
            };
        }

        function applyBackgroundStateFromPeer(payload) {
            if (!payload) return;
            if (payload.useGradient || !payload.imageData) resetBackgroundToGradient({ silentSync: true });
            else setBackgroundImageFromData(payload.imageData, { silentSync: true });
            appendSessionLog('background', payload.useGradient ? 'Gradient restored from peer.' : 'Background synced from peer.');
        }

        // Immediate Audio Wake Up
        function wakeAudio() {
            ZenAudio.warmUp();
            document.removeEventListener('touchstart', wakeAudio);
            document.removeEventListener('mousedown', wakeAudio);
        }
        document.addEventListener('touchstart', wakeAudio, {passive: false});
        document.addEventListener('mousedown', wakeAudio);

        function handleInputStart(x,y, options = {}) { 
            ZenAudio.warmUp(); // Instant engagement
            document.getElementById('overlay').style.opacity='0'; 
            startX=x; startY=y; 
            dragStart=Date.now(); 
            isDragging=false; 
        }
        
        function handleInputMove(x,y, options = {}) {
            if(!startX) return;
            if(Math.sqrt((x-startX)**2 + (y-startY)**2) > 10) {
                isDragging=true;
                
                // Trail Logic: Switch randomly every 10s
                if(!options.sharedTrail && Date.now() - config.lastTrailSwitch > 10000) {
                    const options = ['â™¥', 'Comet', 'â˜ï¸', 'â­'];
                    if (config.currentTrail !== 'â™¥' && Math.random() > 0.4) {
                        config.currentTrail = 'â™¥';
                    } else {
                        config.currentTrail = options[Math.floor(Math.random() * options.length)];
                    }
                    config.lastTrailSwitch = Date.now();
                }

                const trailType = options.sharedTrail || config.currentTrail;
                visualEntities.push(new TrailBase(x, y, trailType));
                
                // Fluid Strumming on Drag
                if(Date.now()-lastDragSound > 60) { 
                    const idx = ZenAudio.getFreqIndex(y, height);
                    ZenAudio.playPluck(ZenAudio.scale[idx], 0.1); 
                    lastDragSound=Date.now(); 
                }
                if (!options.silentSync && Date.now() - lastSyncDragEmit > 120) {
                    sendSync('drag', { x1: startX, y1: startY, x2: x, y2: y, trail: trailType });
                    lastSyncDragEmit = Date.now();
                }
            }
        }

        function handleInputEnd(x,y, options = {}) {
            const now = Date.now();
            if(isDragging) { 
                if (!options.skipTelemetry) registerInput('S'); 
                checkDragUnlock(now-dragStart); 
                const trailType = options.sharedTrail || config.currentTrail;
                if (!options.skipTelemetry) appendSessionLog('drag', `Drag to ${Math.round(x)}, ${Math.round(y)} (${trailType})`, options);
                if (!options.silentSync) sendSync('drag', { x1: startX, y1: startY, x2: x, y2: y, trail: trailType });
            } else {
                const idx = ZenAudio.getFreqIndex(y, height);
                const freq = ZenAudio.scale[idx];
                const visualKind = options.sharedVisual || (() => {
                    const rnd = Math.random();
                    if(foundEggs.includes(3) && rnd > 0.7) return 'growing-heart';
                    if(foundEggs.includes(3) && rnd > 0.5) return 'heart-bloom';
                    return 'bloom';
                })();
                const wordChoice = options.sharedWord || getRandomWord();

                const ent = visualKind === 'growing-heart' ? new GrowingHeart(x,y)
                            : visualKind === 'heart-bloom' ? new HeartBloom(x,y)
                            : new Bloom(x,y);

                visualEntities.push(ent);
                wordEntities.push(new Word(x,y-30, wordChoice));
                
                ZenAudio.playPluck(freq, 0.3);
                
                if (!options.skipTelemetry) {
                    window.telemetryStats.taps++;
                    registerInput('T');
                }

                const isNearLastTap = lastTapX !== null && lastTapY !== null && Math.hypot(x - lastTapX, y - lastTapY) <= DOUBLE_TAP_DISTANCE;
                const isDoubleTap = options.forceDouble || ((now - lastTap) < DOUBLE_TAP_WINDOW && isNearLastTap);

                if(isDoubleTap) {
                    visualEntities.push(new HeartCloud(x,y));
                    ZenAudio.playChord(idx);
                    if (!options.skipTelemetry) window.telemetryStats.drags++;
                    appendSessionLog('tap', `Tap at ${Math.round(x)}, ${Math.round(y)} [double]`, options);
                    if (!options.silentSync) sendSync('tap', { x, y, word: wordChoice, visual: visualKind, double: true });
                } else {
                    appendSessionLog('tap', `Tap at ${Math.round(x)}, ${Math.round(y)} (${visualKind})`, options);
                    if (!options.silentSync) sendSync('tap', { x, y, word: wordChoice, visual: visualKind, double: false });
                }
                if (window.gardenRelaySend) window.gardenRelaySend('tap', { x: Math.round(x), y: Math.round(y), double: isDoubleTap, word: wordChoice });
                lastTap = now;
                lastTapX = x;
                lastTapY = y;
            }
            startX=null; isDragging=false;
        }
        
        canvas.addEventListener('mousedown',e=>handleInputStart(e.clientX,e.clientY));
        canvas.addEventListener('mousemove',e=>{if(startX)handleInputMove(e.clientX,e.clientY)});
        canvas.addEventListener('mouseup',e=>handleInputEnd(e.clientX,e.clientY));
        canvas.addEventListener('touchstart',e=>{e.preventDefault();handleInputStart(e.touches[0].clientX,e.touches[0].clientY)},{passive:false});
        canvas.addEventListener('touchmove',e=>{e.preventDefault();if(startX)handleInputMove(e.touches[0].clientX,e.touches[0].clientY)},{passive:false});
        canvas.addEventListener('touchend',e=>{e.preventDefault();if(e.changedTouches.length)handleInputEnd(e.changedTouches[0].clientX,e.changedTouches[0].clientY)});

        function simulateTap(x, y, options = {}) {
            handleInputStart(x, y, options);
            setTimeout(() => handleInputEnd(x, y, options), 30);
        }

        function simulateDrag(x1, y1, x2, y2, options = {}) {
            const steps = 6;
            handleInputStart(x1, y1, options);
            for (let i=1; i<=steps; i++) {
                const t = i/steps;
                setTimeout(() => handleInputMove(x1 + (x2 - x1)*t, y1 + (y2 - y1)*t, options), t * 400);
            }
            setTimeout(() => handleInputEnd(x2, y2, options), 450);
        }

        // --- 5. Secrets Logic ---
        const rhythmSequences = [
            { code: "TTT", id: 1, desc: "Tap Tap Tap", title: "Jewel Core" }, 
            { code: "TTS", id: 2, desc: "Tap Tap Swipe", title: "Gold Filigree" }, 
            { code: "TST", id: 3, desc: "Tap Swipe Tap", title: "Amour Bloom & Heart 3D" }, 
            { code: "SST", id: 4, desc: "Swipe Swipe Tap", title: "Dimension Heart" }, 
            { code: "TTTT", id: 5, desc: "Tap Tap Tap Tap", title: "Stardust Legacy" }, 
            { code: "SS", id: 6, desc: "Swipe Swipe", title: "Removed (You)" },
            { code: "TSTS", id: 7, desc: "Tap Swipe Tap Swipe", title: "Secret 7" }, 
            { code: "STST", id: 8, desc: "Swipe Tap Swipe Tap", title: "Secret 8" }, 
            { code: "TSS", id: 9, desc: "Tap Swipe Swipe", title: "Secret 9" }, 
            { code: "SSS", id: 10, desc: "Swipe Swipe Swipe", title: "Secret 10" }
        ];

        function registerInput(char) {
            inputBuffer += char; if(inputBuffer.length>5) inputBuffer=inputBuffer.slice(-5);
            rhythmSequences.forEach(seq => { if(inputBuffer.endsWith(seq.code)) triggerUnlock(seq.id); });
        }
        function checkDragUnlock(dur) {
            const sec = 10 + Math.floor(dur/1000) - 1;
            if(sec>10 && sec<=20) triggerUnlock(sec);
        }
        function triggerUnlock(id) {
            inputBuffer="";
            if(!foundEggs.includes(id)) {
                foundEggs.push(id); localStorage.setItem('garden_egg_ids', JSON.stringify(foundEggs));
                
                let b = new Bloom(width/2, height/2, 200);
                if(id===3) b = new GrowingHeart(width/2, height/2); 
                visualEntities.push(b);
                
                // TELEMETRY SECRET
                window.telemetryStats.secrets++;

                ZenAudio.playDiscovery(); 
                updateSecretsUI();
            }
        }

        // --- 6. Rendering ---
        function drawBackground(ctx, img, cw, ch) {
            if (!img.complete || img.naturalWidth === 0) return;
            const scale = Math.max(cw / img.width, ch / img.height);
            const x = (cw / 2) - (img.width / 2) * scale;
            const y = (ch / 2) - (img.height / 2) * scale;
            ctx.drawImage(img, x, y, img.width * scale, img.height * scale);
        }

        const TARGET_FRAME_MS = 1000 / 60;
        let lastFrameTime = performance.now();

        function loop(timestamp) {
            const delta = timestamp - lastFrameTime;

            if (delta >= TARGET_FRAME_MS) {
                lastFrameTime = timestamp - (delta % TARGET_FRAME_MS);

                // Note: width/height are logical pixels from resize()
                // ctx is already scaled by dpr, so we draw using logical coordinates
                
                if(config.useGradient || !config.backgroundImage) {
                    const t=themes[config.currentThemeIndex]; const g=ctx.createLinearGradient(0,0,0,height);
                    g.addColorStop(0,t.bg[0]); g.addColorStop(1,t.bg[1]); ctx.fillStyle=g; ctx.fillRect(0,0,width,height);
                } else {
                    drawBackground(ctx, config.backgroundImage, width, height);
                }

                for(let i=visualEntities.length-1; i>=0; i--) { visualEntities[i].update(); if(visualEntities[i].isDead()) visualEntities.splice(i,1); }
                for(let i=wordEntities.length-1; i>=0; i--) { wordEntities[i].update(); if(wordEntities[i].isDead()) wordEntities.splice(i,1); }
                for(let i=particles.length-1; i>=0; i--) { particles[i].update(); particles[i].draw(ctx); if(particles[i].isDead()) particles.splice(i,1); }

                visualEntities.forEach(e => e.draw(ctx));
                wordEntities.forEach(w => w.draw(ctx));

                document.getElementById('clock').innerText = new Date().toLocaleTimeString();
            }

            requestAnimationFrame(loop);
        }

        // --- 7. UI Logic ---
        const bgInput=document.getElementById('bg-upload-input');
        
        document.getElementById('apply-bg-btn').addEventListener('click', ()=>{
            const f=bgInput.files[0]; if(!f){alert("Please select an image file first.");return;}
            const r=new FileReader(); 
            r.onload=async e=>{ 
                await setBackgroundImageFromData(e.target.result, { notifyOnFail: true, optimize: true });
                appendSessionLog('background', 'Applied custom background.');
            }; 
            r.readAsDataURL(f);
        });
        
        document.getElementById('reset-bg-btn').addEventListener('click', ()=>{ 
            resetBackgroundToGradient();
            appendSessionLog('background', 'Background reset to gradient.');
        });
        if(currentBgData){ setBackgroundImageFromData(currentBgData, { persist: false }); }

        const panel=document.getElementById('settings-panel');
        document.getElementById('settings-trigger').onclick = ()=>panel.classList.remove('translate-x-full');
        document.getElementById('close-btn').onclick = ()=>panel.classList.add('translate-x-full');
        document.getElementById('audio-toggle').onchange=e=>{
            ZenAudio.enabled=e.target.checked;
            appendSessionLog('audio', `Audio ${ZenAudio.enabled ? 'on' : 'muted'}.`);
            sendSync('audio', { enabled: ZenAudio.enabled }, 'state');
        };
        
        document.getElementById('decay-slider').oninput=e=>config.decayValue=[0,0.002,0.005,0.01,0.02,0.05][e.target.value];
        document.getElementById('trail-slider').oninput=e=>{
            const val = parseInt(e.target.value);
            const decays = [0.1, 0.08, 0.06, 0.04, 0.02, 0.01, 0.008, 0.005, 0.002, 0.0005];
            const speeds = [3.0, 2.5, 2.0, 1.5, 1.0, 0.8, 0.6, 0.4, 0.2, 0.1];
            config.trailDecay = decays[val-1];
            config.trailSpeed = speeds[val-1];
        };
        document.getElementById('speed-slider').oninput=e=>config.speedMultiplier=0.2+(e.target.value/100)*1.8;
        
        document.getElementById('theme-btn').onclick=()=>{config.currentThemeIndex=(config.currentThemeIndex+1)%themes.length; sendSync('state-sync', { state: getStateSnapshot() }, 'state');};
        document.getElementById('clear-btn').onclick=()=>{visualEntities=[];wordEntities=[];particles=[];};
        document.getElementById('save-btn').onclick=()=>{const a=document.createElement('a');a.download='garden.png';a.href=canvas.toDataURL();a.click();};
        const cBox=document.getElementById('custom-words');
        cBox.value=localStorage.getItem('garden_words')||"";
        cBox.onblur=e=>{
            localStorage.setItem('garden_words',e.target.value);
            if(e.target.value==='6969') config.customWords=[...config.defaultWords,...secretWords];
            else config.customWords=e.target.value.split(',').filter(s=>s.trim());
            sendSync('custom-words', { words: config.customWords }, 'state');
        };

        const modals = {
            secrets: document.getElementById('secrets-modal'),
            code: document.getElementById('code-modal'),
            req: document.getElementById('req-modal'),
            autoplay: document.getElementById('autoplay-modal')
        };

        function toggleModal(id, show) {
            const el = modals[id];
            const content = el.querySelector('.modal-content') || el.querySelector('div');
            if(show) { 
                updateSecretsUI(); 
                el.classList.remove('invisible'); el.classList.add('visible');
                content.classList.remove('scale-out'); content.classList.add('scale-in');
                panel.classList.add('translate-x-full'); 
            } else { 
                el.classList.remove('visible'); el.classList.add('invisible');
                content.classList.remove('scale-in'); content.classList.add('scale-out');
            }
        }

        document.getElementById('secrets-btn').onclick=()=>toggleModal('secrets', true);
        document.getElementById('close-secrets').onclick=()=>toggleModal('secrets', false);
        document.getElementById('autoplay-btn').onclick=()=>toggleModal('autoplay', true);
        document.getElementById('close-autoplay').onclick=()=>toggleModal('autoplay', false);
        document.getElementById('info-btn').onclick=()=>{
            document.getElementById('source-code-display').textContent = document.documentElement.outerHTML;
            toggleModal('code', true);
        };
        document.getElementById('close-code').onclick=()=>toggleModal('code', false);
        document.getElementById('req-btn').onclick=()=>toggleModal('req', true);
        document.getElementById('close-req').onclick=()=>toggleModal('req', false);
        document.getElementById('copy-code-btn').onclick=()=>{
            navigator.clipboard.writeText(document.documentElement.outerHTML).then(() => {
                alert("Code copied to clipboard!");
            });
        };
        document.getElementById('back-to-grid').onclick=()=>{
            document.getElementById('secrets-detail-view').classList.add('hidden');
            document.getElementById('secrets-grid-view').classList.remove('hidden');
        };

        function updateSecretsUI() {
            const list=document.getElementById('secrets-list'); list.innerHTML='';
            for(let i=1; i<=20; i++) {
                const u = foundEggs.includes(i);
                const b = document.createElement('button');
                b.className = `aspect-square rounded flex items-center justify-center text-xs font-bold border transition-all ${u?'bg-amber-200 border-amber-400 text-amber-900 cursor-pointer hover:bg-amber-300':'bg-gray-100 text-gray-300 cursor-default'}`;
                b.innerText=i;
                if(u) b.onclick=()=>showDetail(i);
                list.appendChild(b);
            }
            document.getElementById('secrets-count').innerText=foundEggs.length;
        }

        function showDetail(id) {
            document.getElementById('secrets-grid-view').classList.add('hidden');
            document.getElementById('secrets-detail-view').classList.remove('hidden');
            document.getElementById('detail-id').innerText=id;
            const seq = rhythmSequences.find(s=>s.id===id);
            const trigger = seq ? seq.desc : `Drag ${id-9}s`;
            const title = seq ? (seq.title || "Secret Unlocked") : "Secret Unlocked";
            
            document.getElementById('detail-title').innerText = title;
            document.getElementById('detail-trigger').innerText = trigger;
            document.getElementById('detail-type').innerText = id<=10?"RHYTHM":"ENDURANCE";
            
            let rewardText = "Mystery Effect";
            if(id===1) rewardText = "Jewel Center (Soft Gradient)";
            if(id===2) rewardText = "Gold Filigree Leaves";
            if(id===3) rewardText = "Fractal Heart Blooms & 3D Hearts";
            if(id===4) rewardText = "Dimensional 3D Hearts";
            if(id===5) rewardText = "Stardust Legacy (Particles)";
            
            document.getElementById('detail-reward').innerText = rewardText;

            document.getElementById('simulate-btn').onclick = () => {
                toggleModal('secrets', false);
                setTimeout(() => {
                    if(id===3) visualEntities.push(new GrowingHeart(width/2, height/2));
                    else if(id===4) visualEntities.push(new HeartCloud(width/2, height/2));
                    else if(id===5) {
                        let b = new Bloom(width/2, height/2, 200);
                        b.alpha = 0.5; 
                        visualEntities.push(b);
                    }
                    else visualEntities.push(new Bloom(width/2, height/2, 200)); 
                    ZenAudio.playDiscovery();
                }, 300);
            };
        }

        // --- Auto-Play Studio ---
        const AUTO_STORAGE_KEY = 'garden_autoplay_settings';
        const AUTO_LIBRARY_KEY = 'garden_autoplay_files';
        const autoInputs = {
            rate: document.getElementById('auto-rate'),
            random: document.getElementById('auto-random'),
            chord: document.getElementById('auto-chord'),
            drags: document.getElementById('auto-drags'),
            soundscape: document.getElementById('auto-soundscape'),
            preset: document.getElementById('auto-preset')
        };
        const autoFileInputs = {
            prefix: document.getElementById('auto-file-prefix'),
            name: document.getElementById('auto-file-name'),
            chooser: document.getElementById('auto-file-chooser'),
            save: document.getElementById('auto-save-file'),
            load: document.getElementById('auto-load-file')
        };
        const autoToggleButton = document.getElementById('auto-toggle');
        const autoToggleLabel = document.getElementById('auto-toggle-label');
        const autoToggleIcon = document.getElementById('auto-toggle-icon');
        const autoRunIcon = document.getElementById('auto-run-icon');
        const autoplayBtn = document.getElementById('autoplay-btn');
        const autoLabels = {
            rate: document.getElementById('auto-rate-label'),
            random: document.getElementById('auto-random-label'),
            chord: document.getElementById('auto-chord-label')
        };
        let autoConfig = {
            rate: 60,
            random: 40,
            chord: 20,
            drags: false,
            soundscape: false,
            preset: 'balanced'
        };
        let autoTimer = null;
        let autoLibrary = [];
        let autoIconClickTimeout = null;

        function saveAutoConfig() { localStorage.setItem(AUTO_STORAGE_KEY, JSON.stringify(autoConfig)); }
        function loadAutoConfig() {
            try {
                const saved = JSON.parse(localStorage.getItem(AUTO_STORAGE_KEY) || '{}');
                autoConfig = { ...autoConfig, ...saved };
            } catch(e){}
            syncAutoUI();
        }
        function syncAutoUI() {
            autoInputs.rate.value = autoConfig.rate;
            autoInputs.random.value = autoConfig.random;
            autoInputs.chord.value = autoConfig.chord;
            autoInputs.drags.checked = autoConfig.drags;
            autoInputs.soundscape.checked = autoConfig.soundscape;
            autoInputs.preset.value = autoConfig.preset;
            autoLabels.rate.innerText = autoConfig.rate;
            autoLabels.random.innerText = `${autoConfig.random}%`;
            autoLabels.chord.innerText = `${autoConfig.chord}%`;
        }
        function loadAutoLibrary() {
            try {
                autoLibrary = JSON.parse(localStorage.getItem(AUTO_LIBRARY_KEY) || '[]');
                if (!Array.isArray(autoLibrary)) autoLibrary = [];
            } catch(e){ autoLibrary = []; }
            refreshAutoFileChooser();
        }
        function saveAutoLibrary() {
            localStorage.setItem(AUTO_LIBRARY_KEY, JSON.stringify(autoLibrary));
        }
        function refreshAutoFileChooser() {
            const prefix = (autoFileInputs.prefix.value || '').trim();
            const filtered = autoLibrary
                .filter(f => !prefix || f.name.startsWith(prefix))
                .sort((a,b)=>a.name.localeCompare(b.name));
            autoFileInputs.chooser.innerHTML = '';
            if (!filtered.length) {
                const opt = document.createElement('option');
                opt.textContent = 'No saved files for this prefix';
                opt.value = '';
                autoFileInputs.chooser.appendChild(opt);
                return;
            }
            filtered.forEach(file => {
                const opt = document.createElement('option');
                opt.value = file.name;
                opt.textContent = file.name;
                autoFileInputs.chooser.appendChild(opt);
            });
        }
        function setAutoPreset(name) {
            if (name === 'calm') autoConfig = { ...autoConfig, rate: 30, random: 20, chord: 10, drags: false, soundscape: true, preset: 'calm' };
            if (name === 'balanced') autoConfig = { ...autoConfig, rate: 60, random: 40, chord: 20, drags: false, soundscape: false, preset: 'balanced' };
            if (name === 'intense') autoConfig = { ...autoConfig, rate: 120, random: 60, chord: 35, drags: true, soundscape: true, preset: 'intense' };
            syncAutoUI(); saveAutoConfig();
        }
        function updateAutoRunUI() {
            const running = !!autoTimer;
            autoToggleLabel.innerText = running ? 'Stop' : 'Start';
            autoToggleIcon.innerText = running ? 'stop_circle' : 'play_arrow';
            autoToggleButton.classList.toggle('bg-indigo-600', !running);
            autoToggleButton.classList.toggle('bg-emerald-600', running);
            autoToggleButton.classList.toggle('hover:bg-indigo-700', !running);
            autoToggleButton.classList.toggle('hover:bg-emerald-700', running);
            autoRunIcon.classList.toggle('ring-4', running);
            autoRunIcon.classList.toggle('ring-emerald-300/60', running);
            autoRunIcon.classList.toggle('bg-emerald-500/80', running);
            autoRunIcon.classList.toggle('bg-indigo-500/80', !running);
            autoplayBtn.classList.toggle('bg-emerald-50', running);
            autoplayBtn.classList.toggle('text-emerald-700', running);
        }
        function autoLoop() {
            const interval = Math.max(200, 60000 / Math.max(1, autoConfig.rate));
            clearInterval(autoTimer);
            autoTimer = setInterval(() => {
                const jitter = autoConfig.random / 100;
                const x = random(40, width-40);
                const y = random(60, height-60);
                const silentOptions = { silentCollab: true, skipTelemetry: true, skipLog: true };
                const shouldDrag = autoConfig.drags && Math.random() < (0.1 + jitter*0.3);
                const shouldChord = Math.random() < (autoConfig.chord/100);
                if (shouldDrag) {
                    const x2 = x + random(-100, 100) * Math.max(0.5, jitter);
                    const y2 = y + random(-80, 120) * Math.max(0.5, jitter);
                    simulateDrag(x, y, Math.max(20, Math.min(width-20, x2)), Math.max(20, Math.min(height-20, y2)), silentOptions);
                } else {
                    simulateTap(x, y, { ...silentOptions, forceDouble: shouldChord && Math.random() < (0.5 + jitter/2) });
                }
                if (autoConfig.soundscape && Math.random() < 0.25) {
                    ZenAudio.playDiscovery();
                }
            }, interval);
            updateAutoRunUI();
        }
        function stopAutoLoop() {
            if (autoTimer) clearInterval(autoTimer);
            autoTimer = null;
            updateAutoRunUI();
        }
        function toggleAutoLoop() {
            if (autoTimer) stopAutoLoop();
            else autoLoop();
        }
        document.getElementById('auto-rate').oninput = e => { autoConfig.rate = parseInt(e.target.value); autoLabels.rate.innerText = autoConfig.rate; saveAutoConfig(); if(autoTimer) autoLoop(); };
        document.getElementById('auto-random').oninput = e => { autoConfig.random = parseInt(e.target.value); autoLabels.random.innerText = `${autoConfig.random}%`; saveAutoConfig(); if(autoTimer) autoLoop(); };
        document.getElementById('auto-chord').oninput = e => { autoConfig.chord = parseInt(e.target.value); autoLabels.chord.innerText = `${autoConfig.chord}%`; saveAutoConfig(); if(autoTimer) autoLoop(); };
        document.getElementById('auto-drags').onchange = e => { autoConfig.drags = e.target.checked; saveAutoConfig(); if(autoTimer) autoLoop(); };
        document.getElementById('auto-soundscape').onchange = e => { autoConfig.soundscape = e.target.checked; saveAutoConfig(); if(autoTimer) autoLoop(); };
        document.getElementById('auto-preset').onchange = e => setAutoPreset(e.target.value);
        document.getElementById('auto-save-preset').onclick = () => { autoConfig.preset = autoInputs.preset.value; saveAutoConfig(); };
        autoToggleButton.onclick = () => { toggleAutoLoop(); };
        autoRunIcon.addEventListener('click', () => {
            if (autoIconClickTimeout) return;
            autoIconClickTimeout = setTimeout(() => {
                toggleAutoLoop();
                autoIconClickTimeout = null;
            }, 200);
        });
        autoRunIcon.addEventListener('dblclick', (e) => {
            e.preventDefault();
            if (autoIconClickTimeout) { clearTimeout(autoIconClickTimeout); autoIconClickTimeout = null; }
            toggleModal('autoplay', true);
        });
        autoFileInputs.prefix.addEventListener('input', refreshAutoFileChooser);
        autoFileInputs.save.addEventListener('click', () => {
            const prefix = (autoFileInputs.prefix.value || '').trim();
            const name = (autoFileInputs.name.value || '').trim();
            if (!name) { alert('Please name your file before saving.'); return; }
            const fileName = `${prefix}${name}`;
            const existingIndex = autoLibrary.findIndex(f => f.name === fileName);
            const payload = { name: fileName, config: { ...autoConfig } };
            if (existingIndex >= 0) autoLibrary[existingIndex] = payload;
            else autoLibrary.push(payload);
            saveAutoLibrary();
            refreshAutoFileChooser();
            autoFileInputs.chooser.value = fileName;
        });
        autoFileInputs.load.addEventListener('click', () => {
            const selected = autoFileInputs.chooser.value;
            if (!selected) return;
            const file = autoLibrary.find(f => f.name === selected);
            if (!file) return;
            autoConfig = { ...autoConfig, ...file.config };
            syncAutoUI(); saveAutoConfig();
            if (autoTimer) autoLoop();
        });
        loadAutoConfig();
        loadAutoLibrary();
        updateAutoRunUI();

        // Recording
        let mediaRecorder, recordedChunks = [], isRecording = false;
        const recBtn = document.getElementById('record-btn');
        const recInd = document.getElementById('rec-indicator');
        
        recBtn.addEventListener('click', () => isRecording ? stopRecording() : startRecording());
        
        function startRecording() {
            // FULL RESET
            ZenAudio.init();
            
            // Clean up old instances if any
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            mediaRecorder = null;
            recordedChunks = [];

            if (ZenAudio.ctx && ZenAudio.ctx.state === 'suspended') {
                ZenAudio.ctx.resume();
            }

            // High Fidelity: Capture stream from the already scaled canvas
            const stream = canvas.captureStream(60); 
            
            // Re-connect fresh audio tracks (Including BG + SFX)
            // ZenAudio.dest receives everything connected to masterGain
            if (ZenAudio.dest && ZenAudio.dest.stream.getAudioTracks().length > 0) {
                const audioTrack = ZenAudio.dest.stream.getAudioTracks()[0].clone();
                stream.addTrack(audioTrack);
            }

            const mimeTypes = [
                "video/mp4", 
                "video/webm;codecs=h264", 
                "video/webm;codecs=vp9", 
                "video/webm"
            ];
            
            let selectedType = mimeTypes.find(type => MediaRecorder.isTypeSupported(type));

            if (!selectedType) { alert("Screen recording is not supported."); return; }

            try { mediaRecorder = new MediaRecorder(stream, { mimeType: selectedType }); } 
            catch (e) { console.error(e); alert("Recording init failed."); return; }

            mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: selectedType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a"); 
                a.style.display="none"; a.href=url; 
                
                let ext = "webm";
                if (selectedType.includes("mp4")) ext = "mp4";
                
                a.download=`garden-${Date.now()}.${ext}`;
                document.body.appendChild(a); a.click(); 
                setTimeout(()=>URL.revokeObjectURL(url),100);
            };
            
            mediaRecorder.start(); isRecording = true; 
            recInd.style.opacity = '1'; recBtn.innerText = "Stop"; 
            recBtn.classList.add('bg-red-100','text-red-700','animate-pulse'); 
            panel.classList.add('translate-x-full');
        }

        function stopRecording() { 
            if(mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop(); 
            isRecording=false; recInd.style.opacity='0'; recBtn.innerText="Record"; 
            recBtn.classList.remove('bg-red-100','text-red-700','animate-pulse'); 
        }

        requestAnimationFrame(loop);
    </script>

    <script>
        // --- 1. CONFIGURATION ---
        const FORM_ID = "1FAIpQLSe3k3uGy3zjEIJ8QVDhjpQOG6EAjWCZ9pCFlhDKle8NeUhg9w"; // Your Real ID
        const MAPPING = {
            "entry.320935448": "@session_end_iso",
            "entry.674244912": "@theme_code",
            "entry.711998658": "@ip_address",
            "entry.463387935": "@session_id",
            "entry.856781419": "@duration_formatted",
            "entry.799073583": "@input_taps",
            "entry.1460702381": "@input_drags",
            "entry.1854966723": "@mouse_pixels_moved",
            "entry.406770144": "@user_agent",
            "entry.339302030": "@platform",
            "entry.1885869286": "@screen_resolution",
            "entry.1550217446": "@window_size",
            "entry.581200255": "@pixel_ratio",
            "entry.720549735": "@color_depth",
            "entry.1134789700": "@cores",
            "entry.1076432340": "@memory",
            "entry.854591687": "@language",
            "entry.101770949": "@timezone",
            "entry.2010953570": "@cookies_enabled",
            "entry.607664253": "@local_storage",
            "entry.1399187003": "@canvas_fingerprint",
            "entry.1854154093": "@referrer",
            "entry.1036649804": "@session_start_iso",
            "entry.1683490369": "@standard_words",
            "entry.1722638233": "@custom_words"
            ,"entry.527394232": "@session_log"
        };

        window.telemetryStats = { taps: 0, drags: 0, secrets: 0, mouseDist: 0 };
        let cachedIP = "pending";

        // --- 2. ASYNC IP FETCH ---
        fetch('https://api.ipify.org?format=json')
            .then(r => r.json()).then(d => cachedIP = d.ip).catch(e => cachedIP = "offline");

        // --- 3. MOUSE TRACKING ---
        let lastMouse = {x:0, y:0};
        document.addEventListener('mousemove', e => {
            if(lastMouse.x!==0) window.telemetryStats.mouseDist += Math.hypot(e.clientX-lastMouse.x, e.clientY-lastMouse.y);
            lastMouse = {x:e.clientX, y:e.clientY};
        });

        // --- 4. DATA COLLECTION & SEND ---
        const getCanvasFP = () => {
            try {
                const c = document.createElement('canvas'); const cx = c.getContext('2d');
                cx.textBaseline = "top"; cx.font = "14px 'Arial'"; cx.fillStyle = "#f60";
                cx.fillRect(125,1,62,20); cx.fillStyle = "#069"; cx.fillText("Garden", 2, 15);
                let b64 = c.toDataURL(); let hash=0; for(let i=0;i<b64.length;i++) hash=Math.imul(31,hash)+b64.charCodeAt(i)|0;
                return Math.abs(hash).toString(16);
            } catch(e) { return "err"; }
        };

        let logSent = false;
        const SESSION_LOG_CHAR_LIMIT = 1800;

        function buildSessionLogString() {
            return sessionLog
                .map(item => `[${new Date(item.ts).toISOString()}] ${item.type}: ${item.detail}`)
                .join(' | ')
                .slice(-SESSION_LOG_CHAR_LIMIT);
        }

        async function sendToPipeline(formData) {
            const url = `https://docs.google.com/forms/d/e/${FORM_ID}/formResponse`;
            try {
                if (navigator.sendBeacon) {
                    const params = new URLSearchParams();
                    formData.forEach((v,k)=>params.append(k,v));
                    if (navigator.sendBeacon(url, params)) return true;
                }
            } catch(e) {
                console.warn('Beacon send failed, falling back to fetch', e);
            }
            try {
                await fetch(url, { method: 'POST', mode: 'no-cors', body: formData, keepalive: true });
                return true;
            } catch(e) {
                console.warn('Pipeline fetch failed', e);
                return false;
            }
        }

        async function logSession(reason = 'unspecified') {
            if (logSent) return;
            logSent = true;
            pipelineSendCount += 1;
            setPipelineStatus('Sending...', 'warn');

            if (!sessionLifecycle.endedAt) sessionLifecycle.endedAt = Date.now();
            if (!sessionLifecycle.endReason) sessionLifecycle.endReason = reason;

            const duration = (sessionLifecycle.endedAt - sessionLifecycle.startedAt) / 1000;
            const startIso = new Date(sessionLifecycle.startedAt).toISOString();
            const endIso = new Date(sessionLifecycle.endedAt).toISOString();
            const c19_session_start_la = new Date(sessionLifecycle.startedAt).toLocaleString('sv', { timeZone: 'America/Los_Angeles' }).replace(' ', 'T');

            const standardWordsString = config.defaultWords.join(', ');
            const customWordsRaw = (config.customWords && config.customWords.length)
                ? config.customWords
                : (typeof cBox !== 'undefined' ? cBox.value.split(',').map(s=>s.trim()).filter(Boolean) : []);
            const customWordsString = customWordsRaw.filter(Boolean).join(', ');
            const dataLayer = {
                "@session_start_iso": startIso,
                "@start_time_la": c19_session_start_la, // C19 Data
                "@session_end_iso": endIso,
                "@duration_formatted": `${Math.floor(duration/60)}m ${Math.floor(duration%60)}s`,
                "@ip_address": cachedIP,
                "@session_id": sessionLifecycle.id,
                "@theme_code": "DEFAULT",
                "@user_agent": navigator.userAgent,
                "@screen_resolution": `${window.screen.width}x${window.screen.height}`,
                "@window_size": `${window.innerWidth}x${window.innerHeight}`,
                "@pixel_ratio": window.devicePixelRatio || 1,
                "@color_depth": window.screen.colorDepth,
                "@cores": navigator.hardwareConcurrency || "ukn",
                "@memory": navigator.deviceMemory || "ukn",
                "@platform": navigator.platform,
                "@language": navigator.language,
                "@timezone": Intl.DateTimeFormat().resolvedOptions().timeZone,
                "@cookies_enabled": navigator.cookieEnabled,
                "@local_storage": (typeof localStorage !== 'undefined') ? 'available' : 'blocked',
                "@canvas_fingerprint": getCanvasFP(),
                "@referrer": document.referrer || "direct",
                "@input_taps": window.telemetryStats.taps,
                "@input_drags": window.telemetryStats.drags,
                "@mouse_pixels_moved": Math.round(window.telemetryStats.mouseDist),
                "@secrets_found_count": window.telemetryStats.secrets,
                "@standard_words": standardWordsString,
                "@custom_words": customWordsString
                ,"@session_log": buildSessionLogString()
            };

            const formData = new FormData();
            for (const [entryId, token] of Object.entries(MAPPING)) {
                let val = token.replace(/@\w+/g, match => dataLayer[match] !== undefined ? dataLayer[match] : match);
                formData.append(entryId, val);
            }

            const ok = await sendToPipeline(formData);
            if (ok) {
                setPipelineStatus(`Sent (${pipelineSendCount})`, 'success');
                appendSessionLog('pipeline', 'Session log submitted.');
            } else {
                setPipelineStatus('Send failed', 'error');
                appendSessionLog('pipeline', 'Session log failed to submit.', { skipLog: false });
            }
        }

        window.addEventListener('beforeunload', () => requestSessionEnd('beforeunload', true));
        window.addEventListener('pagehide', () => requestSessionEnd('pagehide', true));
        window.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                requestSessionEnd('visibility-hidden', false);
            } else {
                cancelSessionEnd('visible');
                appendSessionLog('session-lifecycle', 'Resumed (visible).');
            }
        });

        ['pointerdown','touchstart','keydown','mousemove'].forEach(evt => {
            window.addEventListener(evt, () => cancelSessionEnd('activity'));
        });
    </script>

    <script>
        const AppState = { bgImage: null, useGradient: true };
        function sanitizeSplashText(value) {
            if (!value) return '';
            const trimmed = value.toString().trim();
            if (!trimmed) return '';
            const lowered = trimmed.toLowerCase();
            const forbiddenTokens = [
                'doctype', '<html', '</html', '<meta', '</meta', '<head', '</head', '<body', '</body',
                'minimum-scale', 'maximum-scale', 'width=device-width'
            ];
            if (forbiddenTokens.some(token => lowered.includes(token))) return '';
            if (trimmed.length > 240) return '';
            if (/[<>]/.test(trimmed)) return '';
            const div = document.createElement('div');
            div.textContent = trimmed;
            return div.textContent;
        }
        async function fetchRemoteSplash() {
            if (!GOOGLE_SHEET_SPLASH_CSV || GOOGLE_SHEET_SPLASH_CSV.includes("YOUR_SHEET_ID")) return;
            try {
                const r = await fetch(GOOGLE_SHEET_SPLASH_CSV, { cache: 'no-store' });
                if (!r.ok) return;
                const csv = await r.text();
                const firstLine = (csv.split(/\r?\n/).find(l => l.trim()) || "").split(',');
                const title = sanitizeSplashText(firstLine[0]);
                if (title) document.getElementById('main-title').textContent = title;
                const subtitle = sanitizeSplashText(firstLine[1]);
                if (subtitle) document.getElementById('main-subtitle-container').textContent = subtitle;
                const message = sanitizeSplashText(firstLine.slice(2).join(','));
                if (message) {
                    const b = document.getElementById('custom-message-container');
                    b.textContent = message;
                    b.classList.remove('hidden');
                }
            } catch(e) { console.warn('splash fetch failed', e); }
        }
        async function initEnvironment() {
            // Text
            try {
                const r = await fetch('msg.txt');
                if (r.ok) {
                    const text = await r.text();
                    const parts = text.split('|');
                    const title = sanitizeSplashText(parts[0]);
                    if(title) document.getElementById('main-title').textContent = title;
                    const subtitle = sanitizeSplashText(parts[1]);
                    if(subtitle) document.getElementById('main-subtitle-container').textContent = subtitle;
                    const message = sanitizeSplashText(parts[2]);
                    if(message) {
                        const b = document.getElementById('custom-message-container');
                        b.textContent = message; b.classList.remove('hidden');
                    }
                }
            } catch(e){}
            fetchRemoteSplash();
            // Audio
            try {
                const r = await fetch('sound.mp3', {method:'HEAD'});
                if(r.ok) {
                    // Added crossorigin for Web Audio security
                    const a = document.createElement('audio'); 
                    a.id='bg-audio-track'; 
                    a.loop=true; 
                    a.src='sound.mp3'; 
                    a.volume=0.2; 
                    a.crossOrigin = "anonymous"; 
                    document.body.appendChild(a);
                    
                    const unlock = ()=>{ 
                        // Route to Web Audio for Recording Sync
                        ZenAudio.connectBackground(a);
                        a.play().catch(()=>{}); 
                        document.removeEventListener('click', unlock); 
                        document.removeEventListener('touchstart', unlock); 
                    };
                    document.addEventListener('click', unlock); document.addEventListener('touchstart', unlock);
                }
            } catch(e){}
            // Image
            for(const ext of ['png','jpg','jpeg','gif']) {
                try {
                    const r = await fetch(`img.${ext}`, {method:'HEAD'});
                    if(r.ok) {
                        const i = new Image(); i.onload = ()=>{ AppState.bgImage=i; AppState.useGradient=false; }; i.src=`img.${ext}`; break;
                    }
                } catch(e){}
            }
        }
        initEnvironment();
    </script>

    <script>
        (() => {
            const params = new URLSearchParams(window.location.search);
            const relaySession = (params.get('session') || '').trim();
            if (!relaySession) return;

            const relayTopic = `garden-demo-${relaySession}`;
            let relaySource = null;
            let relayTimer = null;
            let relayBackoff = 1000;
            let relayLastTs = 0;

            const badge = document.createElement('div');
            badge.id = 'relay-status';
            badge.textContent = 'Relay: connectingâ€¦';
            Object.assign(badge.style, {
                position: 'fixed',
                left: '12px',
                bottom: '18px',
                zIndex: '60',
                padding: '8px 12px',
                borderRadius: '999px',
                background: 'rgba(15,23,42,0.75)',
                color: '#e2e8f0',
                border: '1px solid rgba(148,163,184,0.25)',
                fontSize: '12px',
                letterSpacing: '0.04em',
                backdropFilter: 'blur(6px)'
            });
            document.body.appendChild(badge);

            function setBadge(text, tone = 'muted') {
                badge.textContent = text;
                badge.style.borderColor = tone === 'error' ? 'rgba(248,113,113,0.6)'
                    : tone === 'ok' ? 'rgba(74,222,128,0.7)'
                    : 'rgba(148,163,184,0.35)';
            }

            function playRelayBeep() {
                try {
                    ZenAudio.warmUp();
                    ZenAudio.playDiscovery();
                } catch (e) {
                    console.warn('relay beep failed', e);
                }
            }

            function relayPulse() {
                const x = width / 2 + (Math.random() - 0.5) * width * 0.25;
                const y = height / 2 + (Math.random() - 0.5) * height * 0.25;
                simulateTap(x, y, { skipTelemetry: true, silentCollab: true, sharedVisual: 'bloom' });
            }

            function applyRelayColor(value) {
                if (!value) return;
                const color = value.toString();
                const currentTheme = themes[config.currentThemeIndex] || { bg: [color, color], text: '#111' };
                themes[config.currentThemeIndex] = { ...currentTheme, bg: [color, color] };
                config.useGradient = true;
                document.body.style.backgroundColor = color;
            }

            function applyRelayText(value) {
                if (!value) return;
                const safe = value.toString();
                const title = document.getElementById('main-title');
                if (title) title.textContent = safe;
            }

            function handleRelayMessage(msg) {
                if (!msg || msg.session !== relaySession || !msg.ts) return;
                if (msg.ts <= relayLastTs) return;
                relayLastTs = msg.ts;
                if (msg.type === 'color') applyRelayColor(msg.value);
                else if (msg.type === 'text') applyRelayText(msg.value);
                else if (msg.type === 'beep') playRelayBeep();
                else if (msg.type === 'tap') { playRelayBeep(); relayPulse(); }
            }

            function connectRelay() {
                if (relaySource) { relaySource.close(); relaySource = null; }
                clearTimeout(relayTimer);
                setBadge('Relay: connectingâ€¦');
                relaySource = new EventSource(`https://ntfy.sh/${relayTopic}/sse`);
                relaySource.onopen = () => { setBadge('Relay: live', 'ok'); relayBackoff = 1000; };
                relaySource.onerror = () => {
                    setBadge('Relay: retryingâ€¦');
                    if (relaySource) { relaySource.close(); relaySource = null; }
                    relayTimer = setTimeout(connectRelay, relayBackoff);
                    relayBackoff = Math.min(relayBackoff * 1.6, 8000);
                };
                relaySource.onmessage = evt => {
                    try {
                        const data = JSON.parse(evt.data);
                        handleRelayMessage(data);
                    } catch (e) {
                        console.warn('relay parse error', e);
                    }
                };
            }

            function sendRelay(type, value) {
                const ts = Date.now();
                const payload = { session: relaySession, type, value, ts };
                relayLastTs = Math.max(relayLastTs, ts);
                fetch(`https://ntfy.sh/${relayTopic}`, {
                    method: 'POST',
                    body: JSON.stringify(payload),
                    headers: { 'Content-Type': 'application/json' }
                }).catch(() => setBadge('Relay: send failed', 'error'));
            }

            window.gardenRelaySend = sendRelay;
            connectRelay();
        })();
    </script>
</body>
</html>
